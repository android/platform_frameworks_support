{
  "comments": [
    {
      "key": {
        "uuid": "4bb05d33_813d8f3b",
        "filename": "room/coroutines/src/main/java/androidx/room/RoomDatabase.kt",
        "patchSetId": 7
      },
      "lineNbr": 45,
      "author": {
        "id": 1274960
      },
      "writtenOn": "2019-02-12T23:58:41Z",
      "side": 1,
      "message": "What happens when two contexts are created at the same, one each by a different thread?",
      "range": {
        "startLine": 45,
        "startChar": 0,
        "endLine": 45,
        "endChar": 28
      },
      "revId": "ef58457af5a904e6c5169173245c5de3e2015c89",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79d960a1_38db87d1",
        "filename": "room/coroutines/src/main/java/androidx/room/RoomDatabase.kt",
        "patchSetId": 7
      },
      "lineNbr": 45,
      "author": {
        "id": 1258207
      },
      "writtenOn": "2019-02-13T19:15:28Z",
      "side": 1,
      "message": "Then we try to acquire two different threads from Room\u0027s executor to be used to dispatch coroutines. Which ever happens to grab the primary connection first will proceed while the other one will get block.\n\nIn a case where there is only one available thread from Room\u0027s executor (others are busy or whatever) then similarly one of the transaction will proceed while the other waits for a free thread to start dispatching.",
      "parentUuid": "4bb05d33_813d8f3b",
      "range": {
        "startLine": 45,
        "startChar": 0,
        "endLine": 45,
        "endChar": 28
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "ef58457af5a904e6c5169173245c5de3e2015c89",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3cb8961_11c297ff",
        "filename": "room/coroutines/src/main/java/androidx/room/RoomDatabase.kt",
        "patchSetId": 7
      },
      "lineNbr": 45,
      "author": {
        "id": 1274960
      },
      "writtenOn": "2019-02-19T18:51:15Z",
      "side": 1,
      "message": "That still results in lock-ordering the callers in some cases, does it not?",
      "parentUuid": "79d960a1_38db87d1",
      "range": {
        "startLine": 45,
        "startChar": 0,
        "endLine": 45,
        "endChar": 28
      },
      "revId": "ef58457af5a904e6c5169173245c5de3e2015c89",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "030a3112_5b0a72d4",
        "filename": "room/coroutines/src/main/java/androidx/room/RoomDatabase.kt",
        "patchSetId": 7
      },
      "lineNbr": 45,
      "author": {
        "id": 1258207
      },
      "writtenOn": "2019-02-19T21:44:59Z",
      "side": 1,
      "message": "Yes it does - same drawback is the original begin / end transaction methods.",
      "parentUuid": "a3cb8961_11c297ff",
      "range": {
        "startLine": 45,
        "startChar": 0,
        "endLine": 45,
        "endChar": 28
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "ef58457af5a904e6c5169173245c5de3e2015c89",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3bbe2691_23c5faba",
        "filename": "room/coroutines/src/main/java/androidx/room/RoomDatabase.kt",
        "patchSetId": 7
      },
      "lineNbr": 86,
      "author": {
        "id": 1274960
      },
      "writtenOn": "2019-02-12T23:58:41Z",
      "side": 1,
      "message": "Doesn\u0027t look like Coroutines has SequentialExecutor yet: https://github.com/Kotlin/kotlinx.coroutines/issues/261\n\nI don\u0027t think this is quite this simple, unfortunately. In particular, rejecting execution because of a timing window isn\u0027t good. It should instead acquire a new thread.",
      "range": {
        "startLine": 86,
        "startChar": 0,
        "endLine": 86,
        "endChar": 55
      },
      "revId": "ef58457af5a904e6c5169173245c5de3e2015c89",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df06f33d_487c23bb",
        "filename": "room/coroutines/src/main/java/androidx/room/RoomDatabase.kt",
        "patchSetId": 7
      },
      "lineNbr": 86,
      "author": {
        "id": 1258207
      },
      "writtenOn": "2019-02-13T19:15:28Z",
      "side": 1,
      "message": "Do you have an example of a bad timing window?\n\nI currently feel this is enough because:\n1. We wrap the given suspend block waiting for all child coroutines before we release the transaction thread.\n2. We don\u0027t support very bad scenarios created by developer errors (GlobalScope.launch, other deferred DAOs).\n3. As other dispatchers, we don\u0027t support being leaked outside the coroutine scope, hence rejecting once released is a sane action.\n\nKeep in mind that the design of this API is to re-route DB operations into this transaction thread, serially, but similar to the Android SQL bindings, block other DB operations outside of the coroutine scope while the transaction is on-going.",
      "parentUuid": "3bbe2691_23c5faba",
      "range": {
        "startLine": 86,
        "startChar": 0,
        "endLine": 86,
        "endChar": 55
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "ef58457af5a904e6c5169173245c5de3e2015c89",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}