{
  "comments": [
    {
      "key": {
        "uuid": "171c1d84_98307ed6",
        "filename": "core/src/main/java/androidx/core/graphics/TypefaceCompatApi21Impl.java",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1106808
      },
      "writtenOn": "2019-01-22T19:15:37Z",
      "side": 1,
      "message": "does this have to be static? can it be lazy?",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 67,
        "endChar": 10
      },
      "revId": "c21bda187c251d2169a41988aa3a40499cb5c27a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "203e69e6_6a0adc40",
        "filename": "core/src/main/java/androidx/core/graphics/TypefaceCompatApi21Impl.java",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1360983
      },
      "writtenOn": "2019-01-23T14:26:09Z",
      "side": 1,
      "message": "Actually, it doesn\u0027t need to be static as there is always just one instance of TypefaceCompatApi21Impl. Similar to TypefaceCompatApi26Impl (but in contrast to how TypefaceCompatApi24Impl deals with the situation), the static members (and member functions) can be made non-static and the code inside the static block can be moved in the constructor.\n\nTo solve this problem (the exception being thrown) we could do the above and then use the fact that Java allows dynamic dispatch in constructors: instead of adding all the code from the static block in the constructor we can add it in an init() method that gets called in TypefaceCompatApi21Impl\u0027s constructor and then in TypefaceCompatApi26Impl we can just override the init() method. This does require making some members non-final though.\n\nWe can also solve the whole \u0027dynamic dispatch in constructor\u0027 problem by just calling init() on a newly constructed object ourselves immediately after creation in the static block of TypefaceCompat.\n\nRegarding lazy initialisation, we can use the above approach with the init() method (we may or may not choose to leave current members static) then add getter wrappers over the four members that are initialised in init() and in the getters we first check if init() was called.\n\nWould you like for me to use one of the above (or a different) approach ?",
      "parentUuid": "171c1d84_98307ed6",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 67,
        "endChar": 10
      },
      "revId": "c21bda187c251d2169a41988aa3a40499cb5c27a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7141ffd3_454cc20a",
        "filename": "core/src/main/java/androidx/core/graphics/TypefaceCompatApi21Impl.java",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1106808
      },
      "writtenOn": "2019-01-23T17:32:48Z",
      "side": 1,
      "message": "Is it possible to have getters for those Method/Constructor/Class, and during first access create them?\n\ngetAddFontWeightStyleMethod() {\n    init() --\u003e init checks it is initialized if not runs the same block, otherwise just returns the static variable (as it is right now)\n}\n\nThis is probably your second solution or a little extension. wdyt?",
      "parentUuid": "203e69e6_6a0adc40",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 67,
        "endChar": 10
      },
      "revId": "c21bda187c251d2169a41988aa3a40499cb5c27a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2a62f2d_5983e42b",
        "filename": "core/src/main/java/androidx/core/graphics/TypefaceCompatApi21Impl.java",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1360983
      },
      "writtenOn": "2019-01-24T12:18:54Z",
      "side": 1,
      "message": "Sounds good, the only thing to note here is that TypefaceCompatApi21Impl would initialize some variables lazily while other classes such as TypefaceCompatApi26Impl wouldn\u0027t, which is arguably a little weird. Shall we agree this is the best solution though ?",
      "parentUuid": "7141ffd3_454cc20a",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 67,
        "endChar": 10
      },
      "revId": "c21bda187c251d2169a41988aa3a40499cb5c27a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49204074_b0105cf0",
        "filename": "core/src/main/java/androidx/core/graphics/TypefaceCompatApi21Impl.java",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1106808
      },
      "writtenOn": "2019-01-24T17:47:06Z",
      "side": 1,
      "message": "I believe the current structure of the inheritance is really far from ideal but there is not a strong reason to fix it right now. \n\nI believe we should agree if lazy init is better or not. If it is static 26Impl will construct its own static variables on top of what is here and they will not use it, therefore it will be doing a relatively expensive work for no reason. \n\nIdeally we should change 26 too to use lazy init since 28 extends from 26. However it is what it is right now, and we are not currently changing that code, so it is up to you to update it or not. \n\nSo the question is do we agree that if we don\u0027t make it lazy, 26,27,28 etc will always do work that will not be used?",
      "parentUuid": "f2a62f2d_5983e42b",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 67,
        "endChar": 10
      },
      "revId": "c21bda187c251d2169a41988aa3a40499cb5c27a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}