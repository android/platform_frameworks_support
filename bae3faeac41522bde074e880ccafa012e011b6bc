{
  "comments": [
    {
      "key": {
        "uuid": "d5059a12_1565ec79",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 27
      },
      "lineNbr": 95,
      "author": {
        "id": 1445442
      },
      "writtenOn": "2019-02-10T13:45:48Z",
      "side": 1,
      "message": "On further reflection, the whole withXXXX concept seems to be weird. First of all this function _suspend_ until some condition is true, yet it is named withXxx and takes a block. So I can write:\n\n```\nwithCreated(lc) { \n   // this get called when the condition is reached (1)\n}\n// this _also_ get called when the condition is reached after (1) finishes.\n```\n\nSo, what is actually the purpose of the block and why it is called withXxx? It looks, by looking at what is does, this function should be named `awaitCreated(lc)`, but still the purpose of having a block parameter is escaping me.",
      "revId": "bae3faeac41522bde074e880ccafa012e011b6bc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ed06173_c0bc9018",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 27
      },
      "lineNbr": 95,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-02-10T20:32:56Z",
      "side": 1,
      "message": "The basic use case for this API looks like: (errors ignored for simplicity)\n\n    // ViewModel\n    suspend fun getTask(id : String) \u003d withContext(Dispatchers.IO) {\n        api.fetchTask(id)\n    }\n\n    // in a ViewController  (Fragment, Activity etc)\n    onViewCreated() {\n        showLoading()\n        viewLifecycleScope.launch {\n            val task \u003d viewModel.getTask(id)\n            withStarted(viewLifecycle) { \n                if (task \u003d\u003d null) navigateBack()\n                else showTask(task)\n            }\n        }\n    }\n\nThis does not look very pretty but gives coroutines a safe way to communicate with the views.\n\nIf it was await, we wouldn\u0027t be able to guarantee that lifecycle did not move backwards when the next line is invoked:\n\ne.g.\n\n    viewLifecycleScope.launch {\n         val task \u003d viewModel.getTask(id)\n         lifecycle.awaitStarted()\n         showTask(task) // lifecycle might\u0027ve already stopped (CREATED state)\n    }\n\nfor the code above, before showTask is  executed, lifecycle may move back to created state.\n\nIf we accepted a suspend block that gets cancelled if lifecycle moves outside the desired state, that would be a misleading API since lifecycle can move back to the desired state. (we would lose the operation that could actually continue)\ne.g.\n    \n    viewLifecycleScope.launch {\n         val task \u003d viewModel.getTask(id)\n         lifecycle.withStarted { // suspend block\n             showTask(task)\n             val details \u003d viewModel.getDetails(task) // another suspend call\n             showDetails(details) // lifecycle may not be started anymore\n         }\n    }\n\n\nThere is another option which we dismissed earlier that I would like to get your opinion.\n\nThe very first prototype we had for this functionality was a custom dispatcher that paused the coroutine if lifecycle goes out of the expected minimum state.\nSomething like:\n\n    viewLifecycleScope.launch(lifecycle.startedDispatcher) {\n         val task \u003d viewModel.getTask(id)\n         showTask(task)\n         val details \u003d viewModel.getDetails(task) // another suspend call\n         showDetails(details) // if lifecycle is stopped, waits until it started again before executing this line\n    }\n\nThat `StartedDispatcher` was a special dispatcher that didn\u0027t run its runnables until the Lifecycle is in desired state. What do you think about it? We thought having a custom dispatcher that might randomly pause would be confusing. In terms of usability, it seem to provide the best API with guarantees. I found a version of it and posted here for reference:\nhttps://gist.github.com/yigit/d5a9d0fd99149bdb1ea8eb29c3f9447a (please don\u0027t judge that code :) just experimenting)\n\nlmk what you think and thanks a lot for your review!",
      "parentUuid": "d5059a12_1565ec79",
      "revId": "bae3faeac41522bde074e880ccafa012e011b6bc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd33cd0b_b785405d",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 27
      },
      "lineNbr": 95,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-02-11T21:18:03Z",
      "side": 1,
      "message": "btw, awaitStarted(block) sounds like a good name, we can make that change. Though it still needs to receive a non-suspend block (unless we go with the dispatcher).\n\nAlso, I\u0027ve extracted some samples for use cases to help clarify expectations:\n\nhttps://gist.github.com/yigit/23594c3c3abb6f29d3a276920490d942",
      "parentUuid": "5ed06173_c0bc9018",
      "revId": "bae3faeac41522bde074e880ccafa012e011b6bc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c719aab_b5ca042c",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 27
      },
      "lineNbr": 95,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-02-12T21:29:26Z",
      "side": 1,
      "message": "Your comment in one of your snippet \"// lifecycle might\u0027ve already stopped (CREATED state)\" is not accurate. I understand your concern, but the good news it that it\u0027s easy to not have the issue you mention in that comment, here\u0027s how:\n\nIf your coroutine dispatcher is Dispatchers.Main, and the `awaitCreated`, `awaitStarted` and `awaitResumed` functions are based on an `awaitState` function that uses `Dispatchers.Main.immediate`, then the coroutine will resume immediately when the lifecycle state reaches at least the desired state, being synchronous until the next suspension point. There\u0027s no need for a dispatcher that magically pauses dispatching based on lifecycle state.\n\nExample of possible implementation for `awaitState`: https://github.com/LouisCAD/Splitties/blob/61e9f223219f0c1c894be77c334d826413ed720c/lifecycle-coroutines/src/main/kotlin/splitties/lifecycle/coroutines/LifecycleAwaitState.kt#L38",
      "parentUuid": "cd33cd0b_b785405d",
      "revId": "bae3faeac41522bde074e880ccafa012e011b6bc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "559da4ba_8273de2e",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 27
      },
      "lineNbr": 95,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-02-12T22:29:50Z",
      "side": 1,
      "message": "that assumes the outer scope is `Dispatchers.Main` which we cannot assume. We could check that we are inside the main thread when the method is called but that only validates for our method, not for the outer scope. We cannot guarantee where / when the outer scope will run so it will be like a footgun.\nmoreover, if it is just await, developer can possibly write:\n\n```\nval data \u003d fetchData()\nawaitStarted()\nupdateUI(data)\nval details \u003d fetchDetails(data)\nupdateDetails(details)\n```\nbecause user is in suspend function, they can easily call another suspend function and the second updateDetails function may run after lifecycle has changed. It is easy to get wrong and not an API we would like to provide.\n\nProviding that await API will require:\n* always call it in Dispatchers.MAIN\n* never make another suspend call while accessing UI.\n\nIf the requirement is going to be never make another suspend call, we can as well receive a non-suspending block to make it impossible (besides launch which is not something that can be fixed).",
      "parentUuid": "9c719aab_b5ca042c",
      "revId": "bae3faeac41522bde074e880ccafa012e011b6bc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "843bec1e_196614d4",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 27
      },
      "lineNbr": 156,
      "author": {
        "id": 1445442
      },
      "writtenOn": "2019-02-10T10:06:45Z",
      "side": 1,
      "message": "It would be way more useful if all withXxx function receive suspending function in its block, e.g. `block: suspend () -\u003e T`. See below at how it could be implemented.",
      "revId": "bae3faeac41522bde074e880ccafa012e011b6bc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69833f0f_051efb48",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 27
      },
      "lineNbr": 173,
      "author": {
        "id": 1445442
      },
      "writtenOn": "2019-02-10T10:06:45Z",
      "side": 1,
      "message": "As a matter of style (and efficiency) it is advised to extract invocations of `suspendCoroutine` into a separate function that is written an expression like this:\n```\nfun suspendUntilState(...) \u003d \n   suspendCancellableCoroutine\u003cT\u003e { \n       // install callback here \u0026 resume when it fires. \n   }\n```",
      "revId": "bae3faeac41522bde074e880ccafa012e011b6bc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1fe91976_a1659d1e",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 27
      },
      "lineNbr": 181,
      "author": {
        "id": 1445442
      },
      "writtenOn": "2019-02-10T10:06:45Z",
      "side": 1,
      "message": "Calling an external block from inside the callback does not seems like a good idea. `suspendCoroutine` functions are designed for integration with callbacks and are supposed to quickly resume the corresponding coroutine. You can put all the other code (like `block()`) invocation _after_ the `suspendCoroutine` invocation, so it gets invoked in a coroutine (with an appropriate context) after its resumption. This also automatically makes it possible to make the corresponding block a suspending function.",
      "revId": "bae3faeac41522bde074e880ccafa012e011b6bc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d6d0db6_41203594",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 27
      },
      "lineNbr": 181,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-02-10T20:32:56Z",
      "side": 1,
      "message": "i\u0027ll add details on why block is not suspend function in the other comment (about awaitXXX).",
      "parentUuid": "1fe91976_a1659d1e",
      "revId": "bae3faeac41522bde074e880ccafa012e011b6bc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}