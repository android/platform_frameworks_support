/*
 * Copyright 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package androidx.room.paging;

import androidx.annotation.NonNull;
import androidx.paging.ItemKeyedDataSource;
import androidx.room.InvalidationTracker;
import androidx.room.RoomDatabase;

import java.util.Set;

/**
 * Paging ItemKeyedDataSource with automatic Room table invalidation tracking.
 * <p>
 * You can extend this class to implement your own {@link ItemKeyedDataSource} backed by Room
 * queries. The DataSource will invalidate itself automatically as tables are modified. This is
 * useful if you want to avoid the drawback of the default LIMIT/OFFSET based
 * {@link androidx.paging.PositionalDataSource} type generated by Room.
 * <p>
 * The primary benefit of using item-based keys is performance consistency. As your query result
 * grows, a position-based approach scales linearly as you load data later in the list. Room
 * currently cannot generate ItemKeyedDataSources, but you can implement your own as shown below.
 * <p>
 * The code below implements a paged query of the {@code user} table, sorted by {@code mId}. It uses
 * multiple queries defined on the Dao to implement the DataSource load methods.
 *
 * <pre>
 * {@literal @}Dao
 * interface UserDao {
 *     // Initial load from beginning of query
 *     {@literal @}Query("SELECT * from user WHERE mAge > :age ORDER BY mId ASC LIMIT :limit")
 *     public abstract List&lt;User> pagedByAgeInitial(int age, int limit);
 *
 *     {@literal @}Query("SELECT * from user WHERE mAge > :age and mId > :key ORDER BY mId ASC LIMIT :limit")
 *     public abstract List&lt;User> pagedByAgeLoadAfter(int age, int key, int limit);
 *
 *     // NOTE: ORDER BY part of query reversed, since we're loading the N=LIMIT items above the key
 *     {@literal @}Query("SELECT * from user WHERE mAge > :age and mId &lt; :key ORDER BY mId DESC LIMIT :limit")
 *     public abstract List&lt;User> pagedByAgeLoadBefore(int age, int key, int limit);
 *
 *     // count methods below are optional - only needed to count placeholders
 *
 *     {@literal @}Query("SELECT COUNT(*) from user WHERE mAge > :age and mId > :key ORDER BY mId ASC")
 *     public abstract int pagedByAgeCountAfter(int age, int key);
 *
 *     {@literal @}Query("SELECT COUNT(*) from user WHERE mAge > :age and mId &lt; :key ORDER BY mId DESC")
 *     public abstract int pagedByAgeCountBefore(int age, int key);
 * }
 *
 * public class AgeKeyedDataSource extends RoomItemKeyedDataSource&lt;Integer, User> {
 *     public static class Factory extends DataSource.Factory&lt;Integer,User> {
 *         final TestDatabase mDb;
 *         final int mMinimumAge;
 *
 *         public Factory(TestDatabase db, int minimumAge) {
 *             mDb = db;
 *             mMinimumAge = minimumAge;
 *         }
 *
 *         {@literal @}NonNull
 *         {@literal @}Override
 *         public DataSource&lt;Integer, User> create() {
 *             return new AgeKeyedDataSource(mDb, mMinimumAge);
 *         }
 *     }
 *
 *     private final int mMinimumAge;
 *     private final UserDao mUserDao;
 *
 *     protected AgeKeyedDataSource(TestDatabase db, int minimumAge) {
 *         super(db, "user");
 *         mUserDao = db.getUserDao();
 *         mMinimumAge = minimumAge;
 *     }
 *
 *     {@literal @}Override
 *     public void loadInitial({@literal @}NonNull LoadInitialParams&lt;Integer> params,
 *             {@literal @}NonNull LoadInitialCallback&lt;User> callback) {
 *         Integer userId = params.requestedInitialKey;
 *         List&lt;User> list;
 *         if (userId != null) {
 *             // initial keyed load - load before 'userId',
 *             // and load after last item in before list
 *             int pageSize = params.requestedLoadSize / 2;
 *             Integer key = userId;
 *             list = mUserDao.pagedByAgeLoadBefore(mMinimumAge, key, pageSize);
 *             Collections.reverse(list);
 *             if (!list.isEmpty()) {
 *                 key = getKey(list.get(list.size() - 1));
 *             }
 *             list.addAll(mUserDao.pagedByAgeLoadAfter(mMinimumAge, key, pageSize));
 *         } else {
 *             list = mUserDao.pagedByAgeInitial(mMinimumAge, params.requestedLoadSize);
 *         }
 *
 *         if (params.placeholdersEnabled) {
 *             if (list.isEmpty()) {
 *                 // empty result, no data
 *                 callback.onResult(list, 0, 0);
 *             } else {
 *                 Integer firstKey = getKey(list.get(0));
 *                 Integer lastKey = getKey(list.get(list.size() - 1));
 *
 *                 // only bother counting if placeholders are desired
 *                 final int position = mUserDao.pagedByAgeCountBefore(mMinimumAge, firstKey);
 *                 final int count = position
 *                         + list.size()
 *                         + mUserDao.pagedByAgeCountAfter(mMinimumAge, lastKey);
 *                 callback.onResult(list, position, count);
 *             }
 *         } else {
 *             callback.onResult(list);
 *         }
 *     }
 *
 *     {@literal @}Override
 *     public void loadAfter({@literal @}NonNull LoadParams&lt;Integer> params,
 *             {@literal @}NonNull LoadCallback&lt;User> callback) {
 *         callback.onResult(mUserDao.pagedByAgeLoadAfter(
 *                 mMinimumAge, params.key, params.requestedLoadSize));
 *     }
 *
 *     {@literal @}Override
 *     public void loadBefore({@literal @}NonNull LoadParams&lt;Integer> params,
 *             {@literal @}NonNull LoadCallback&lt;User> callback) {
 *         List&lt;User> list = mUserDao.pagedByAgeLoadBefore(
 *                 mMinimumAge, params.key, params.requestedLoadSize);
 *         // Note: db loadBefore query has to be reversed, since we want to return mId ascending.
 *         Collections.reverse(list);
 *         callback.onResult(list);
 *     }
 *
 *     {@literal @}NonNull
 *     {@literal @}Override
 *     public Integer getKey(@NonNull User item) {
 *         return item.getId();
 *     }
 * }
 *
 * class MyViewModel extends ViewModel {
 *     public final LiveData&lt;PagedList&lt;User>> usersList;
 *     public MyViewModel(MyDatabase database) {
 *         usersList = new LivePagedListBuilder&lt;>(
 *                 new AgeKeyedDataSource.Factory(database), /* page size {@literal *}/ 20).build();
 *     }
 * }
 * </pre>
 *
 * @param <K> Type of data used to query Value types out of the DataSource.
 * @param <V> Type of items being loaded by the DataSource.
 *
 * @see ItemKeyedDataSource
 */
public abstract class RoomItemKeyedDataSource<K, V> extends ItemKeyedDataSource<K, V> {
    private final RoomDatabase mDb;
    @SuppressWarnings("FieldCanBeLocal")
    private final InvalidationTracker.Observer mObserver;

    protected RoomItemKeyedDataSource(RoomDatabase db, String... tables) {
        mDb = db;
        mObserver = new InvalidationTracker.Observer(tables) {
            @Override
            public void onInvalidated(@NonNull Set<String> tables) {
                invalidate();
            }
        };
        db.getInvalidationTracker().addWeakObserver(mObserver);
    }

    @Override
    public boolean isInvalid() {
        mDb.getInvalidationTracker().refreshVersionsSync();
        return super.isInvalid();
    }
}
