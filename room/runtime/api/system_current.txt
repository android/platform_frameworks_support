// Signature format: 2.0
package androidx.room {

  public class DatabaseConfiguration {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public DatabaseConfiguration(android.content.Context, String?, androidx.sqlite.db.SupportSQLiteOpenHelper.Factory, androidx.room.RoomDatabase.MigrationContainer, java.util.List<androidx.room.RoomDatabase.Callback>?, boolean, androidx.room.RoomDatabase.JournalMode!, java.util.concurrent.Executor, boolean, boolean, boolean, java.util.Set<java.lang.Integer>?);
    field private final java.util.Set<java.lang.Integer>! mMigrationNotRequiredFrom;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public abstract class EntityDeletionOrUpdateAdapter<T> extends androidx.room.SharedSQLiteStatement {
    ctor public EntityDeletionOrUpdateAdapter(androidx.room.RoomDatabase!);
    method protected abstract void bind(androidx.sqlite.db.SupportSQLiteStatement!, T!);
    method protected abstract String! createQuery();
    method public final int handle(T!);
    method public final int handleMultiple(Iterable<T>!);
    method public final int handleMultiple(T[]!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public abstract class EntityInsertionAdapter<T> extends androidx.room.SharedSQLiteStatement {
    ctor public EntityInsertionAdapter(androidx.room.RoomDatabase!);
    method protected abstract void bind(androidx.sqlite.db.SupportSQLiteStatement!, T!);
    method public final void insert(T!);
    method public final void insert(T[]!);
    method public final void insert(Iterable<T>!);
    method public final long insertAndReturnId(T!);
    method public final long[]! insertAndReturnIdsArray(java.util.Collection<T>!);
    method public final long[]! insertAndReturnIdsArray(T[]!);
    method public final Long[]! insertAndReturnIdsArrayBox(java.util.Collection<T>!);
    method public final Long[]! insertAndReturnIdsArrayBox(T[]!);
    method public final java.util.List<java.lang.Long>! insertAndReturnIdsList(T[]!);
    method public final java.util.List<java.lang.Long>! insertAndReturnIdsList(java.util.Collection<T>!);
  }

  public class InvalidationTracker {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public InvalidationTracker(androidx.room.RoomDatabase!, java.lang.String...!);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public InvalidationTracker(androidx.room.RoomDatabase!, java.util.Map<java.lang.String,java.lang.String>!, java.util.Map<java.lang.String,java.util.Set<java.lang.String>>!, java.lang.String...!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void addWeakObserver(androidx.room.InvalidationTracker.Observer!);
    method private static void appendTriggerName(StringBuilder!, String!, String!);
    method boolean ensureInitialization();
    method void internalInit(androidx.sqlite.db.SupportSQLiteDatabase!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @VisibleForTesting(otherwise=androidx.annotation.VisibleForTesting.PACKAGE_PRIVATE) public void notifyObserversByTableNames(java.lang.String...!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @WorkerThread public void refreshVersionsSync();
    method private String[]! resolveViews(String[]!);
    method void startMultiInstanceInvalidation(android.content.Context!, String!);
    method private void startTrackingTable(androidx.sqlite.db.SupportSQLiteDatabase!, int);
    method void stopMultiInstanceInvalidation();
    method private void stopTrackingTable(androidx.sqlite.db.SupportSQLiteDatabase!, int);
    method void syncTriggers(androidx.sqlite.db.SupportSQLiteDatabase!);
    method void syncTriggers();
    field private static final String CREATE_TRACKING_TABLE_SQL = "CREATE TEMP TABLE room_table_modification_log(table_id INTEGER PRIMARY KEY, invalidated INTEGER NOT NULL DEFAULT 0)";
    field private static final String INVALIDATED_COLUMN_NAME = "invalidated";
    field @VisibleForTesting static final String RESET_UPDATED_TABLES_SQL = "UPDATE room_table_modification_log SET invalidated = 0 WHERE invalidated = 1 ";
    field @VisibleForTesting static final String SELECT_UPDATED_TABLES_SQL = "SELECT * FROM room_table_modification_log WHERE invalidated = 1;";
    field private static final String TABLE_ID_COLUMN_NAME = "table_id";
    field private static final String[]! TRIGGERS;
    field private static final String UPDATE_TABLE_NAME = "room_table_modification_log";
    field volatile androidx.sqlite.db.SupportSQLiteStatement! mCleanupStatement;
    field final androidx.room.RoomDatabase! mDatabase;
    field private volatile boolean mInitialized;
    field private androidx.room.MultiInstanceInvalidationClient! mMultiInstanceInvalidationClient;
    field private androidx.room.InvalidationTracker.ObservedTableTracker! mObservedTableTracker;
    field @VisibleForTesting final androidx.arch.core.internal.SafeIterableMap<androidx.room.InvalidationTracker.Observer,androidx.room.InvalidationTracker.ObserverWrapper>! mObserverMap;
    field java.util.concurrent.atomic.AtomicBoolean! mPendingRefresh;
    field @VisibleForTesting Runnable! mRefreshRunnable;
    field @VisibleForTesting final androidx.collection.SparseArrayCompat<java.lang.String> mShadowTableLookup;
    field @VisibleForTesting final androidx.collection.ArrayMap<java.lang.String,java.lang.Integer> mTableIdLookup;
    field @VisibleForTesting final java.util.BitSet mTableInvalidStatus;
    field final String[]! mTableNames;
    field private java.util.Map<java.lang.String,java.util.Set<java.lang.String>> mViewTables;
  }

  static class InvalidationTracker.ObservedTableTracker {
    ctor InvalidationTracker.ObservedTableTracker(int);
    method int[]? getTablesToSync();
    method boolean onAdded(int...!);
    method boolean onRemoved(int...!);
    method void onSyncCompleted();
    field static final int ADD = 1; // 0x1
    field static final int NO_OP = 0; // 0x0
    field static final int REMOVE = 2; // 0x2
    field boolean mNeedsSync;
    field boolean mPendingSync;
    field final long[]! mTableObservers;
    field final int[]! mTriggerStateChanges;
    field final boolean[]! mTriggerStates;
  }

  public abstract static class InvalidationTracker.Observer {
    method boolean isRemote();
    field final String[]! mTables;
  }

  static class InvalidationTracker.ObserverWrapper {
    ctor InvalidationTracker.ObserverWrapper(androidx.room.InvalidationTracker.Observer!, int[]!, String[]!);
    method void notifyByTableNames(String[]!);
    method void notifyByTableVersions(java.util.BitSet!);
    field final androidx.room.InvalidationTracker.Observer! mObserver;
    field private final java.util.Set<java.lang.String>! mSingleTableSet;
    field final int[]! mTableIds;
    field private final String[]! mTableNames;
  }

  static class InvalidationTracker.WeakObserver extends androidx.room.InvalidationTracker.Observer {
    ctor InvalidationTracker.WeakObserver(androidx.room.InvalidationTracker!, androidx.room.InvalidationTracker.Observer!);
    field final java.lang.ref.WeakReference<androidx.room.InvalidationTracker.Observer>! mDelegateRef;
    field final androidx.room.InvalidationTracker! mTracker;
  }

  class MultiInstanceInvalidationClient {
    ctor MultiInstanceInvalidationClient(android.content.Context!, String!, androidx.room.InvalidationTracker!, java.util.concurrent.Executor!);
    method void stop();
    field final IMultiInstanceInvalidationCallback! mCallback;
    field int mClientId;
    field android.content.Context? mContext;
    field final java.util.concurrent.Executor! mExecutor;
    field final androidx.room.InvalidationTracker! mInvalidationTracker;
    field final String! mName;
    field final androidx.room.InvalidationTracker.Observer! mObserver;
    field final Runnable! mRemoveObserverRunnable;
    field IMultiInstanceInvalidationService? mService;
    field final android.content.ServiceConnection! mServiceConnection;
    field final Runnable! mSetUpRunnable;
    field final java.util.concurrent.atomic.AtomicBoolean! mStopped;
    field private final Runnable! mTearDownRunnable;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class MultiInstanceInvalidationService extends android.app.Service {
    ctor public MultiInstanceInvalidationService();
    field private final IMultiInstanceInvalidationService.Stub! mBinder;
    field final android.os.RemoteCallbackList<IMultiInstanceInvalidationCallback>! mCallbackList;
    field final androidx.collection.SparseArrayCompat<java.lang.String>! mClientNames;
    field int mMaxClientId;
  }

  public class Room {
    method static <T, C> T getGeneratedImplementation(Class<C>!, String!);
    field private static final String CURSOR_CONV_SUFFIX = "_CursorConverter";
    field static final String LOG_TAG = "ROOM";
  }

  public abstract class RoomDatabase {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void assertNotMainThread();
    method java.util.concurrent.locks.Lock! getCloseLock();
    method private static boolean isMainThread();
    field private static final String DB_IMPL_SUFFIX = "_Impl";
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final int MAX_BIND_PARAMETER_CNT = 999; // 0x3e7
    field private boolean mAllowMainThreadQueries;
    field private final java.util.concurrent.locks.ReentrantLock! mCloseLock;
    field private final androidx.room.InvalidationTracker! mInvalidationTracker;
    field private androidx.sqlite.db.SupportSQLiteOpenHelper! mOpenHelper;
    field private java.util.concurrent.Executor! mQueryExecutor;
    field boolean mWriteAheadLoggingEnabled;
  }

  public static class RoomDatabase.Builder<T extends androidx.room.RoomDatabase> {
    ctor RoomDatabase.Builder(android.content.Context, Class<T>, String?);
    field private boolean mAllowDestructiveMigrationOnDowngrade;
    field private boolean mAllowMainThreadQueries;
    field private java.util.ArrayList<androidx.room.RoomDatabase.Callback>! mCallbacks;
    field private final android.content.Context! mContext;
    field private final Class<T>! mDatabaseClass;
    field private androidx.sqlite.db.SupportSQLiteOpenHelper.Factory! mFactory;
    field private androidx.room.RoomDatabase.JournalMode! mJournalMode;
    field private final androidx.room.RoomDatabase.MigrationContainer! mMigrationContainer;
    field private java.util.Set<java.lang.Integer>! mMigrationStartAndEndVersions;
    field private java.util.Set<java.lang.Integer>! mMigrationsNotRequiredFrom;
    field private boolean mMultiInstanceInvalidation;
    field private final String! mName;
    field private java.util.concurrent.Executor! mQueryExecutor;
    field private boolean mRequireMigration;
  }

  public static enum RoomDatabase.JournalMode {
    method androidx.room.RoomDatabase.JournalMode! resolve(android.content.Context!);
  }

  public static class RoomDatabase.MigrationContainer {
    method private void addMigration(androidx.room.migration.Migration!);
    method private java.util.List<androidx.room.migration.Migration>! findUpMigrationPath(java.util.List<androidx.room.migration.Migration>!, boolean, int, int);
    field private androidx.collection.SparseArrayCompat<androidx.collection.SparseArrayCompat<androidx.room.migration.Migration>>! mMigrations;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class RoomOpenHelper extends androidx.sqlite.db.SupportSQLiteOpenHelper.Callback {
    ctor public RoomOpenHelper(androidx.room.DatabaseConfiguration, androidx.room.RoomOpenHelper.Delegate, String, String);
    ctor public RoomOpenHelper(androidx.room.DatabaseConfiguration, androidx.room.RoomOpenHelper.Delegate, String);
    method private void checkIdentity(androidx.sqlite.db.SupportSQLiteDatabase!);
    method private void createMasterTableIfNotExists(androidx.sqlite.db.SupportSQLiteDatabase!);
    method private static boolean hasRoomMasterTable(androidx.sqlite.db.SupportSQLiteDatabase!);
    method private void updateIdentity(androidx.sqlite.db.SupportSQLiteDatabase!);
    field private androidx.room.DatabaseConfiguration? mConfiguration;
    field private final androidx.room.RoomOpenHelper.Delegate mDelegate;
    field private final String mIdentityHash;
    field private final String mLegacyHash;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public abstract static class RoomOpenHelper.Delegate {
    ctor public RoomOpenHelper.Delegate(int);
    method protected abstract void createAllTables(androidx.sqlite.db.SupportSQLiteDatabase!);
    method protected abstract void dropAllTables(androidx.sqlite.db.SupportSQLiteDatabase!);
    method protected abstract void onCreate(androidx.sqlite.db.SupportSQLiteDatabase!);
    method protected abstract void onOpen(androidx.sqlite.db.SupportSQLiteDatabase!);
    method protected void onPostMigrate(androidx.sqlite.db.SupportSQLiteDatabase!);
    method protected void onPreMigrate(androidx.sqlite.db.SupportSQLiteDatabase!);
    method protected abstract void validateMigration(androidx.sqlite.db.SupportSQLiteDatabase!);
    field public final int version;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class RoomSQLiteQuery implements androidx.sqlite.db.SupportSQLiteProgram androidx.sqlite.db.SupportSQLiteQuery {
    ctor private RoomSQLiteQuery(int);
    method public static androidx.room.RoomSQLiteQuery! acquire(String!, int);
    method public void copyArgumentsFrom(androidx.room.RoomSQLiteQuery!);
    method public static androidx.room.RoomSQLiteQuery! copyFrom(androidx.sqlite.db.SupportSQLiteQuery!);
    method void init(String!, int);
    method private static void prunePoolLocked();
    method public void release();
    field private static final int BLOB = 5; // 0x5
    field @VisibleForTesting static final int DESIRED_POOL_SIZE = 10; // 0xa
    field private static final int DOUBLE = 3; // 0x3
    field private static final int LONG = 2; // 0x2
    field private static final int NULL = 1; // 0x1
    field @VisibleForTesting static final int POOL_LIMIT = 15; // 0xf
    field private static final int STRING = 4; // 0x4
    field @VisibleForTesting int mArgCount;
    field private final int[]! mBindingTypes;
    field @VisibleForTesting final byte[][]! mBlobBindings;
    field @VisibleForTesting final int mCapacity;
    field @VisibleForTesting final double[]! mDoubleBindings;
    field @VisibleForTesting final long[]! mLongBindings;
    field private volatile String! mQuery;
    field @VisibleForTesting final String[]! mStringBindings;
    field @VisibleForTesting static final java.util.TreeMap<java.lang.Integer,androidx.room.RoomSQLiteQuery>! sQueryPool;
  }

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) @IntDef({androidx.room.RoomSQLiteQuery.NULL, androidx.room.RoomSQLiteQuery.LONG, androidx.room.RoomSQLiteQuery.DOUBLE, androidx.room.RoomSQLiteQuery.STRING, androidx.room.RoomSQLiteQuery.BLOB}) static @interface RoomSQLiteQuery.Binding {
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public abstract class SharedSQLiteStatement {
    ctor public SharedSQLiteStatement(androidx.room.RoomDatabase!);
    method public androidx.sqlite.db.SupportSQLiteStatement! acquire();
    method protected void assertNotMainThread();
    method private androidx.sqlite.db.SupportSQLiteStatement! createNewStatement();
    method protected abstract String! createQuery();
    method private androidx.sqlite.db.SupportSQLiteStatement! getStmt(boolean);
    method public void release(androidx.sqlite.db.SupportSQLiteStatement!);
    field private final androidx.room.RoomDatabase! mDatabase;
    field private final java.util.concurrent.atomic.AtomicBoolean! mLock;
    field private volatile androidx.sqlite.db.SupportSQLiteStatement! mStmt;
  }

}

package androidx.room.paging {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public abstract class LimitOffsetDataSource<T> extends androidx.paging.PositionalDataSource<T> {
    ctor protected LimitOffsetDataSource(androidx.room.RoomDatabase!, androidx.sqlite.db.SupportSQLiteQuery!, boolean, java.lang.String...!);
    ctor protected LimitOffsetDataSource(androidx.room.RoomDatabase!, androidx.room.RoomSQLiteQuery!, boolean, java.lang.String...!);
    method protected abstract java.util.List<T>! convertRows(android.database.Cursor!);
    method public int countItems();
    method public java.util.List<T>? loadRange(int, int);
    field private final String! mCountQuery;
    field private final androidx.room.RoomDatabase! mDb;
    field private final boolean mInTransaction;
    field private final String! mLimitOffsetQuery;
    field private final androidx.room.InvalidationTracker.Observer! mObserver;
    field private final androidx.room.RoomSQLiteQuery! mSourceQuery;
  }

}

package androidx.room.util {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class CursorUtil {
    ctor private CursorUtil();
    method public static android.database.Cursor copyAndClose(android.database.Cursor);
    method public static int getColumnIndex(android.database.Cursor, String);
    method public static int getColumnIndexOrThrow(android.database.Cursor, String);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class DBUtil {
    ctor private DBUtil();
    method public static void dropFtsSyncTriggers(androidx.sqlite.db.SupportSQLiteDatabase!);
    method public static android.database.Cursor query(androidx.room.RoomDatabase!, androidx.sqlite.db.SupportSQLiteQuery!, boolean);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class FtsTableInfo {
    ctor public FtsTableInfo(String!, java.util.Set<java.lang.String>!, java.util.Set<java.lang.String>!);
    ctor public FtsTableInfo(String!, java.util.Set<java.lang.String>!, String!);
    method @VisibleForTesting static java.util.Set<java.lang.String>! parseOptions(String!);
    method public static androidx.room.util.FtsTableInfo! read(androidx.sqlite.db.SupportSQLiteDatabase!, String!);
    method private static java.util.Set<java.lang.String>! readColumns(androidx.sqlite.db.SupportSQLiteDatabase!, String!);
    method private static java.util.Set<java.lang.String>! readOptions(androidx.sqlite.db.SupportSQLiteDatabase!, String!);
    field private static final String[]! FTS_OPTIONS;
    field public final java.util.Set<java.lang.String>! columns;
    field public final String! name;
    field public final java.util.Set<java.lang.String>! options;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class StringUtil {
    ctor private StringUtil();
    method public static void appendPlaceholders(StringBuilder!, int);
    method public static String? joinIntoString(java.util.List<java.lang.Integer>?);
    method public static StringBuilder! newStringBuilder();
    method public static java.util.List<java.lang.Integer>? splitToIntList(String?);
    field public static final String[]! EMPTY_STRING_ARRAY;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class TableInfo {
    ctor public TableInfo(String!, java.util.Map<java.lang.String,androidx.room.util.TableInfo.Column>!, java.util.Set<androidx.room.util.TableInfo.ForeignKey>!, java.util.Set<androidx.room.util.TableInfo.Index>!);
    ctor public TableInfo(String!, java.util.Map<java.lang.String,androidx.room.util.TableInfo.Column>!, java.util.Set<androidx.room.util.TableInfo.ForeignKey>!);
    method public static androidx.room.util.TableInfo! read(androidx.sqlite.db.SupportSQLiteDatabase!, String!);
    method private static java.util.Map<java.lang.String,androidx.room.util.TableInfo.Column>! readColumns(androidx.sqlite.db.SupportSQLiteDatabase!, String!);
    method private static java.util.List<androidx.room.util.TableInfo.ForeignKeyWithSequence>! readForeignKeyFieldMappings(android.database.Cursor!);
    method private static java.util.Set<androidx.room.util.TableInfo.ForeignKey>! readForeignKeys(androidx.sqlite.db.SupportSQLiteDatabase!, String!);
    method private static androidx.room.util.TableInfo.Index? readIndex(androidx.sqlite.db.SupportSQLiteDatabase!, String!, boolean);
    method private static java.util.Set<androidx.room.util.TableInfo.Index>? readIndices(androidx.sqlite.db.SupportSQLiteDatabase!, String!);
    field public final java.util.Map<java.lang.String,androidx.room.util.TableInfo.Column>! columns;
    field public final java.util.Set<androidx.room.util.TableInfo.ForeignKey>! foreignKeys;
    field public final java.util.Set<androidx.room.util.TableInfo.Index>? indices;
    field public final String! name;
  }

  public static class TableInfo.Column {
    ctor public TableInfo.Column(String!, String!, boolean, int);
    method private static int findAffinity(String?);
    method public boolean isPrimaryKey();
    field public final int affinity;
    field public final String! name;
    field public final boolean notNull;
    field public final int primaryKeyPosition;
    field public final String! type;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static class TableInfo.ForeignKey {
    ctor public TableInfo.ForeignKey(String, String, String, java.util.List<java.lang.String>, java.util.List<java.lang.String>);
    field public final java.util.List<java.lang.String> columnNames;
    field public final String onDelete;
    field public final String onUpdate;
    field public final java.util.List<java.lang.String> referenceColumnNames;
    field public final String referenceTable;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) static class TableInfo.ForeignKeyWithSequence implements java.lang.Comparable<androidx.room.util.TableInfo.ForeignKeyWithSequence> {
    ctor TableInfo.ForeignKeyWithSequence(int, int, String!, String!);
    field final String! mFrom;
    field final int mId;
    field final int mSequence;
    field final String! mTo;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static class TableInfo.Index {
    ctor public TableInfo.Index(String!, boolean, java.util.List<java.lang.String>!);
    field public static final String DEFAULT_PREFIX = "index_";
    field public final java.util.List<java.lang.String>! columns;
    field public final String! name;
    field public final boolean unique;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class ViewInfo {
    ctor public ViewInfo(String!, String!);
    method public static androidx.room.util.ViewInfo! read(androidx.sqlite.db.SupportSQLiteDatabase!, String!);
    field public final String! name;
    field public final String! sql;
  }

}

