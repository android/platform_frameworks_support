package androidx.work {

  public final class ArrayCreatingInputMerger extends androidx.work.InputMerger {
    ctor public ArrayCreatingInputMerger();
    method public androidx.work.Data merge(java.util.List<androidx.work.Data>);
  }

  public final class BackoffPolicy extends java.lang.Enum {
    method public static androidx.work.BackoffPolicy valueOf(java.lang.String);
    method public static final androidx.work.BackoffPolicy[] values();
    enum_constant public static final androidx.work.BackoffPolicy EXPONENTIAL;
    enum_constant public static final androidx.work.BackoffPolicy LINEAR;
  }

  public final class Configuration {
    method public java.util.concurrent.Executor getExecutor();
    method public int getMaxJobSchedulerID();
    method public int getMinJobSchedulerID();
    method public androidx.work.WorkerFactory getWorkerFactory();
    field public static final int MIN_SCHEDULER_LIMIT = 20; // 0x14
  }

  public static final class Configuration.Builder {
    ctor public Configuration.Builder();
    method public androidx.work.Configuration build();
    method public androidx.work.Configuration.Builder setExecutor(java.util.concurrent.Executor);
    method public androidx.work.Configuration.Builder setJobSchedulerJobIdRange(int, int);
    method public androidx.work.Configuration.Builder setMaxSchedulerLimit(int);
    method public androidx.work.Configuration.Builder setMinimumLoggingLevel(int);
    method public androidx.work.Configuration.Builder setWorkerFactory(androidx.work.WorkerFactory);
  }

  public final class Constraints {
    ctor public Constraints(androidx.work.Constraints);
    method public androidx.work.ContentUriTriggers getContentUriTriggers();
    method public androidx.work.NetworkType getRequiredNetworkType();
    method public boolean hasContentUriTriggers();
    method public boolean requiresBatteryNotLow();
    method public boolean requiresCharging();
    method public boolean requiresDeviceIdle();
    method public boolean requiresStorageNotLow();
    method public void setContentUriTriggers(androidx.work.ContentUriTriggers);
    method public void setRequiredNetworkType(androidx.work.NetworkType);
    method public void setRequiresBatteryNotLow(boolean);
    method public void setRequiresCharging(boolean);
    method public void setRequiresDeviceIdle(boolean);
    method public void setRequiresStorageNotLow(boolean);
    field public static final androidx.work.Constraints NONE;
  }

  public static final class Constraints.Builder {
    ctor public Constraints.Builder();
    method public androidx.work.Constraints.Builder addContentUriTrigger(android.net.Uri, boolean);
    method public androidx.work.Constraints build();
    method public androidx.work.Constraints.Builder setRequiredNetworkType(androidx.work.NetworkType);
    method public androidx.work.Constraints.Builder setRequiresBatteryNotLow(boolean);
    method public androidx.work.Constraints.Builder setRequiresCharging(boolean);
    method public androidx.work.Constraints.Builder setRequiresDeviceIdle(boolean);
    method public androidx.work.Constraints.Builder setRequiresStorageNotLow(boolean);
  }

  public final class ContentUriTriggers implements java.lang.Iterable {
    ctor public ContentUriTriggers();
    method public void add(android.net.Uri, boolean);
    method public java.util.Iterator<androidx.work.ContentUriTriggers.Trigger> iterator();
    method public int size();
  }

  public static final class ContentUriTriggers.Trigger {
    method public android.net.Uri getUri();
    method public boolean shouldTriggerForDescendants();
  }

  public final class Data {
    ctor public Data(androidx.work.Data);
    method public boolean getBoolean(java.lang.String, boolean);
    method public boolean[] getBooleanArray(java.lang.String);
    method public double getDouble(java.lang.String, double);
    method public double[] getDoubleArray(java.lang.String);
    method public float getFloat(java.lang.String, float);
    method public float[] getFloatArray(java.lang.String);
    method public int getInt(java.lang.String, int);
    method public int[] getIntArray(java.lang.String);
    method public java.util.Map<java.lang.String, java.lang.Object> getKeyValueMap();
    method public long getLong(java.lang.String, long);
    method public long[] getLongArray(java.lang.String);
    method public java.lang.String getString(java.lang.String);
    method public java.lang.String[] getStringArray(java.lang.String);
    method public int size();
    field public static final androidx.work.Data EMPTY;
    field public static final int MAX_DATA_BYTES = 10240; // 0x2800
  }

  public static final class Data.Builder {
    ctor public Data.Builder();
    method public androidx.work.Data build();
    method public androidx.work.Data.Builder putAll(androidx.work.Data);
    method public androidx.work.Data.Builder putAll(java.util.Map<java.lang.String, java.lang.Object>);
    method public androidx.work.Data.Builder putBoolean(java.lang.String, boolean);
    method public androidx.work.Data.Builder putBooleanArray(java.lang.String, boolean[]);
    method public androidx.work.Data.Builder putDouble(java.lang.String, double);
    method public androidx.work.Data.Builder putDoubleArray(java.lang.String, double[]);
    method public androidx.work.Data.Builder putFloat(java.lang.String, float);
    method public androidx.work.Data.Builder putFloatArray(java.lang.String, float[]);
    method public androidx.work.Data.Builder putInt(java.lang.String, int);
    method public androidx.work.Data.Builder putIntArray(java.lang.String, int[]);
    method public androidx.work.Data.Builder putLong(java.lang.String, long);
    method public androidx.work.Data.Builder putLongArray(java.lang.String, long[]);
    method public androidx.work.Data.Builder putString(java.lang.String, java.lang.String);
    method public androidx.work.Data.Builder putStringArray(java.lang.String, java.lang.String[]);
  }

  public class DefaultWorkerFactory implements androidx.work.WorkerFactory {
    ctor public DefaultWorkerFactory();
    method public androidx.work.Worker createWorker(android.content.Context, java.lang.String, androidx.work.WorkerParameters);
  }

  public final class ExistingPeriodicWorkPolicy extends java.lang.Enum {
    method public static androidx.work.ExistingPeriodicWorkPolicy valueOf(java.lang.String);
    method public static final androidx.work.ExistingPeriodicWorkPolicy[] values();
    enum_constant public static final androidx.work.ExistingPeriodicWorkPolicy KEEP;
    enum_constant public static final androidx.work.ExistingPeriodicWorkPolicy REPLACE;
  }

  public final class ExistingWorkPolicy extends java.lang.Enum {
    method public static androidx.work.ExistingWorkPolicy valueOf(java.lang.String);
    method public static final androidx.work.ExistingWorkPolicy[] values();
    enum_constant public static final androidx.work.ExistingWorkPolicy APPEND;
    enum_constant public static final androidx.work.ExistingWorkPolicy KEEP;
    enum_constant public static final androidx.work.ExistingWorkPolicy REPLACE;
  }

  public abstract class InputMerger {
    ctor public InputMerger();
    method public abstract androidx.work.Data merge(java.util.List<androidx.work.Data>);
  }

  public final class NetworkType extends java.lang.Enum {
    method public static androidx.work.NetworkType valueOf(java.lang.String);
    method public static final androidx.work.NetworkType[] values();
    enum_constant public static final androidx.work.NetworkType CONNECTED;
    enum_constant public static final androidx.work.NetworkType METERED;
    enum_constant public static final androidx.work.NetworkType NOT_REQUIRED;
    enum_constant public static final androidx.work.NetworkType NOT_ROAMING;
    enum_constant public static final androidx.work.NetworkType UNMETERED;
  }

  public abstract class NonBlockingWorker {
    ctor public deprecated NonBlockingWorker();
    ctor public NonBlockingWorker(android.content.Context, androidx.work.WorkerParameters);
    method public final android.content.Context getApplicationContext();
    method public final java.util.UUID getId();
    method public final androidx.work.Data getInputData();
    method public final android.net.Network getNetwork();
    method public androidx.work.Data getOutputData();
    method public final int getRunAttemptCount();
    method public final java.util.Set<java.lang.String> getTags();
    method public final java.lang.String[] getTriggeredContentAuthorities();
    method public final android.net.Uri[] getTriggeredContentUris();
    method protected deprecated void internalInit(android.content.Context, androidx.work.WorkerParameters);
    method public final boolean isCancelled();
    method public final boolean isStopped();
    method public void onStopped(boolean);
    method public void setOutputData(androidx.work.Data);
  }

  public final class OneTimeWorkRequest extends androidx.work.WorkRequest {
    method public static java.util.List<androidx.work.OneTimeWorkRequest> from(java.lang.Class<? extends androidx.work.Worker>...);
    method public static java.util.List<androidx.work.OneTimeWorkRequest> from(java.util.List<java.lang.Class<? extends androidx.work.Worker>>);
  }

  public static final class OneTimeWorkRequest.Builder extends androidx.work.WorkRequest.Builder {
    ctor public OneTimeWorkRequest.Builder(java.lang.Class<? extends androidx.work.Worker>);
    method public androidx.work.OneTimeWorkRequest.Builder setInitialDelay(long, java.util.concurrent.TimeUnit);
    method public androidx.work.OneTimeWorkRequest.Builder setInitialDelay(java.time.Duration);
    method public androidx.work.OneTimeWorkRequest.Builder setInputMerger(java.lang.Class<? extends androidx.work.InputMerger>);
  }

  public final class OverwritingInputMerger extends androidx.work.InputMerger {
    ctor public OverwritingInputMerger();
    method public androidx.work.Data merge(java.util.List<androidx.work.Data>);
  }

  public final class PeriodicWorkRequest extends androidx.work.WorkRequest {
    field public static final long MIN_PERIODIC_FLEX_MILLIS = 300000L; // 0x493e0L
    field public static final long MIN_PERIODIC_INTERVAL_MILLIS = 900000L; // 0xdbba0L
  }

  public static final class PeriodicWorkRequest.Builder extends androidx.work.WorkRequest.Builder {
    ctor public PeriodicWorkRequest.Builder(java.lang.Class<? extends androidx.work.Worker>, long, java.util.concurrent.TimeUnit);
    ctor public PeriodicWorkRequest.Builder(java.lang.Class<? extends androidx.work.Worker>, java.time.Duration);
    ctor public PeriodicWorkRequest.Builder(java.lang.Class<? extends androidx.work.Worker>, long, java.util.concurrent.TimeUnit, long, java.util.concurrent.TimeUnit);
    ctor public PeriodicWorkRequest.Builder(java.lang.Class<? extends androidx.work.Worker>, java.time.Duration, java.time.Duration);
  }

  public final class State extends java.lang.Enum {
    method public boolean isFinished();
    method public static androidx.work.State valueOf(java.lang.String);
    method public static final androidx.work.State[] values();
    enum_constant public static final androidx.work.State BLOCKED;
    enum_constant public static final androidx.work.State CANCELLED;
    enum_constant public static final androidx.work.State ENQUEUED;
    enum_constant public static final androidx.work.State FAILED;
    enum_constant public static final androidx.work.State RUNNING;
    enum_constant public static final androidx.work.State SUCCEEDED;
  }

  public abstract interface SynchronousWorkContinuation {
    method public abstract void enqueueSync();
    method public abstract java.util.List<androidx.work.WorkStatus> getStatusesSync();
  }

  public abstract interface SynchronousWorkManager {
    method public abstract void cancelAllWorkByTagSync(java.lang.String);
    method public abstract void cancelAllWorkSync();
    method public abstract void cancelUniqueWorkSync(java.lang.String);
    method public abstract void cancelWorkByIdSync(java.util.UUID);
    method public abstract void enqueueSync(androidx.work.WorkRequest...);
    method public abstract void enqueueSync(java.util.List<? extends androidx.work.WorkRequest>);
    method public abstract void enqueueUniquePeriodicWorkSync(java.lang.String, androidx.work.ExistingPeriodicWorkPolicy, androidx.work.PeriodicWorkRequest);
    method public abstract long getLastCancelAllTimeMillisSync();
    method public abstract androidx.work.WorkStatus getStatusByIdSync(java.util.UUID);
    method public abstract java.util.List<androidx.work.WorkStatus> getStatusesByTagSync(java.lang.String);
    method public abstract java.util.List<androidx.work.WorkStatus> getStatusesForUniqueWorkSync(java.lang.String);
    method public abstract void pruneWorkSync();
  }

  public abstract class WorkContinuation {
    ctor public WorkContinuation();
    method public static androidx.work.WorkContinuation combine(androidx.work.WorkContinuation...);
    method public static androidx.work.WorkContinuation combine(java.util.List<androidx.work.WorkContinuation>);
    method public static androidx.work.WorkContinuation combine(androidx.work.OneTimeWorkRequest, androidx.work.WorkContinuation...);
    method public static androidx.work.WorkContinuation combine(androidx.work.OneTimeWorkRequest, java.util.List<androidx.work.WorkContinuation>);
    method public abstract void enqueue();
    method public abstract android.arch.lifecycle.LiveData<java.util.List<androidx.work.WorkStatus>> getStatuses();
    method public abstract androidx.work.SynchronousWorkContinuation synchronous();
    method public final androidx.work.WorkContinuation then(androidx.work.OneTimeWorkRequest...);
    method public abstract androidx.work.WorkContinuation then(java.util.List<androidx.work.OneTimeWorkRequest>);
  }

  public abstract class WorkManager {
    method public final androidx.work.WorkContinuation beginUniqueWork(java.lang.String, androidx.work.ExistingWorkPolicy, androidx.work.OneTimeWorkRequest...);
    method public abstract androidx.work.WorkContinuation beginUniqueWork(java.lang.String, androidx.work.ExistingWorkPolicy, java.util.List<androidx.work.OneTimeWorkRequest>);
    method public final androidx.work.WorkContinuation beginWith(androidx.work.OneTimeWorkRequest...);
    method public abstract androidx.work.WorkContinuation beginWith(java.util.List<androidx.work.OneTimeWorkRequest>);
    method public abstract void cancelAllWork();
    method public abstract void cancelAllWorkByTag(java.lang.String);
    method public abstract void cancelUniqueWork(java.lang.String);
    method public abstract void cancelWorkById(java.util.UUID);
    method public final void enqueue(androidx.work.WorkRequest...);
    method public abstract void enqueue(java.util.List<? extends androidx.work.WorkRequest>);
    method public abstract void enqueueUniquePeriodicWork(java.lang.String, androidx.work.ExistingPeriodicWorkPolicy, androidx.work.PeriodicWorkRequest);
    method public static androidx.work.WorkManager getInstance();
    method public abstract android.arch.lifecycle.LiveData<java.lang.Long> getLastCancelAllTimeMillis();
    method public abstract android.arch.lifecycle.LiveData<androidx.work.WorkStatus> getStatusById(java.util.UUID);
    method public abstract android.arch.lifecycle.LiveData<java.util.List<androidx.work.WorkStatus>> getStatusesByTag(java.lang.String);
    method public abstract android.arch.lifecycle.LiveData<java.util.List<androidx.work.WorkStatus>> getStatusesForUniqueWork(java.lang.String);
    method public static void initialize(android.content.Context, androidx.work.Configuration);
    method public abstract void pruneWork();
    method public abstract androidx.work.SynchronousWorkManager synchronous();
  }

  public abstract class WorkRequest {
    method public java.util.UUID getId();
    field public static final long DEFAULT_BACKOFF_DELAY_MILLIS = 30000L; // 0x7530L
    field public static final long MAX_BACKOFF_MILLIS = 18000000L; // 0x112a880L
    field public static final long MIN_BACKOFF_MILLIS = 10000L; // 0x2710L
  }

  public static abstract class WorkRequest.Builder<B extends androidx.work.WorkRequest.Builder, W extends androidx.work.WorkRequest> {
    method public final B addTag(java.lang.String);
    method public final W build();
    method public final B keepResultsForAtLeast(long, java.util.concurrent.TimeUnit);
    method public final B keepResultsForAtLeast(java.time.Duration);
    method public final B setBackoffCriteria(androidx.work.BackoffPolicy, long, java.util.concurrent.TimeUnit);
    method public final B setConstraints(androidx.work.Constraints);
    method public final B setInputData(androidx.work.Data);
  }

  public final class WorkStatus {
    ctor public WorkStatus(java.util.UUID, androidx.work.State, androidx.work.Data, java.util.List<java.lang.String>);
    method public java.util.UUID getId();
    method public androidx.work.Data getOutputData();
    method public androidx.work.State getState();
    method public java.util.Set<java.lang.String> getTags();
  }

  public abstract class Worker extends androidx.work.NonBlockingWorker {
    ctor public deprecated Worker();
    ctor public Worker(android.content.Context, androidx.work.WorkerParameters);
    method public abstract androidx.work.Worker.Result doWork();
  }

  public static final class Worker.Result extends java.lang.Enum {
    method public static androidx.work.Worker.Result valueOf(java.lang.String);
    method public static final androidx.work.Worker.Result[] values();
    enum_constant public static final androidx.work.Worker.Result FAILURE;
    enum_constant public static final androidx.work.Worker.Result RETRY;
    enum_constant public static final androidx.work.Worker.Result SUCCESS;
  }

  public abstract interface WorkerFactory {
    method public abstract androidx.work.Worker createWorker(android.content.Context, java.lang.String, androidx.work.WorkerParameters);
  }

  public final class WorkerParameters {
    method public java.util.UUID getId();
    method public androidx.work.Data getInputData();
    method public android.net.Network getNetwork();
    method public int getRunAttemptCount();
    method public java.util.Set<java.lang.String> getTags();
    method public java.lang.String[] getTriggeredContentAuthorities();
    method public android.net.Uri[] getTriggeredContentUris();
  }

}

