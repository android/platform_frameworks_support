{
  "comments": [
    {
      "key": {
        "uuid": "3b719b54_6dd6fc62",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 36,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T00:33:57Z",
      "side": 1,
      "message": "Using this property would be quite redundant readability wise: `lifecycle.lifecycleScope`, the word lifecycle is repeated.\nAlso, it may be unclear that we\u0027re talking about a `CoroutineScope` if user code has symbols or types that include the word `scope` but are not related to coroutines.\n\nConsequently, I suggest to rename this as `coroutineScope`, so usage would look so instead: `lifecycle.coroutineScope`.\n\nAnother possibility is calling it `mainScope` since it dispatches on the main thread, and the naming would align with `MainScope()` which is already present in kotlinx.coroutines.",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7ef07b8_ea8da9f2",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 36,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "view model uses viewModelScope so i was trying to match that. in Lifecycle it does sound weird though (LifecycleOwner will be fine since you are very likely to use it inside a LifecycleOwner anyways). we\u0027ll rethink this.",
      "parentUuid": "3b719b54_6dd6fc62",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38195cd2_28aa9422",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 36,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T07:37:40Z",
      "side": 1,
      "message": "I may not be in the right place to comment on this, but I think `viewModelScope` should include the word `main` in its name, and there could be a lazily evaluated `defaultScope` property dispatching on `Dispatchers.Default` (sharing the `Job` instance with the one dispatching on main thread), and the same could be done for I/O with `Dispatchers.IO`.\nIn a ViewModel, you\u0027re more likely to work off the main thread, do calculations that involve the CPU, or do blocking I/O, and only posting to LiveDatas or going back on main thread to sync results.",
      "parentUuid": "d7ef07b8_ea8da9f2",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f28e31e2_3d75129b",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 36,
      "author": {
        "id": 1014545
      },
      "writtenOn": "2019-01-30T21:34:45Z",
      "side": 1,
      "message": "I kind of agree with coroutineScope here but leave it as lifecycleScope (or lifecycleCoroutineScope) in LifecycleOwner. Reason being that both ViewModel and LifecycleOwner are implemented by user code and the namespace may become ambiguous. For Lifecycle, not so much.",
      "parentUuid": "38195cd2_28aa9422",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4612b674_d7ed7f25",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 36,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-30T21:35:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "38195cd2_28aa9422",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7cfe6cc2_ef9469b8",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 39,
      "author": {
        "id": 1232209
      },
      "writtenOn": "2019-01-23T21:45:04Z",
      "side": 1,
      "message": "This should be `as LifecycleCoroutineScope?` which casts to a nullable type. The current code falls back to null when the cast fails which has the chance of hiding bugs should some other type be set.",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ff9c0bc8_c31905de",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 39,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "sgtm, will change.",
      "parentUuid": "7cfe6cc2_ef9469b8",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0a078836_6271fb71",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 39,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-28T06:55:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ff9c0bc8_c31905de",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b51f3f64_33ec7c17",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1434600
      },
      "writtenOn": "2019-01-23T10:38:32Z",
      "side": 1,
      "message": "Shouldn\u0027t it be SupervisorJob?\nIf any coroutine launched within this scope fails, scope becomes cancelled, while lifecycle is still active.",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2930b1c_9422fbdc",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T00:33:57Z",
      "side": 1,
      "message": "About `Dispatchers.Main`: there\u0027s currently a performance issue with it on Android because of how ServiceLoader used for initialization \"performs\" blocking I/O: https://github.com/Kotlin/kotlinx.coroutines/issues/878\n\nYou can track a D8 desugaring fix here: https://issuetracker.google.com/issues/120436373\n\nIn the meantime, there\u0027s a workaround which is using the `asCoroutineDispatcher` extension function on a `Handler` that is linked to the main thread. You can take this as an example: https://github.com/LouisCAD/Splitties/blob/8a38de6131b1b41d5404c8f236204cfa7becc3b8/lifecycle-coroutines/src/main/kotlin/splitties/lifecycle/coroutines/AndroidMainDispatcher.kt#L17\n\nUsing this workaround for lifecycle scopes could avoid a performance hit, and would prevent from negating the efforts of developers using it to avoid the problem.",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b665030_f56f8288",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "we actually want any failure in these coroutines to crash the app. i will verify it works that way.",
      "parentUuid": "b51f3f64_33ec7c17",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9b902f1_b7a874e3",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "not sure if that would work w/ the `Dispatchers.Main` replacement test artifact so I don\u0027t want to rely on being \"the\" main thread.\nFor the IO hit, i assume it is cached (will check) so it should be a shared cost.\nIn any case, we would still prefer to use Dispatchers.Main and rely on slowdown issue being solved on the coroutines side.",
      "parentUuid": "a2930b1c_9422fbdc",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "13339b66_08948d26",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T07:37:40Z",
      "side": 1,
      "message": "This is not the behavior you\u0027ll get. If a coroutine launched from this scope is cancelled (for example a `CancellationException` or subclass thrown inside a `launch` lambda because of a call to `withTimeout(millis) { ... }` that timed out), then all subsequent attempts to launch a coroutine, and all running coroutines will result in being cancelled, which will put the app into an inconsistent near-dead state, without any crash (normal cancellation should never crash anyway).\n\nThe same would happen if you call `async { ... }` from this scope and it fails inside (and is properly caught at `await()` call place.\n\nThat is the reason why there\u0027s `SupervisorJob()` provided in kotlinx.coroutines, and it needs to be used there.\n\nFYI, I made this mistake in the past (using `Job()` for lifecycle coroutine scope), and in my case, if first attempt to do something failed normally (with no uncaught exception), all subsequent attempts would be cancelled straightaway.",
      "parentUuid": "1b665030_f56f8288",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b1638ae_c3ad3914",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T07:37:40Z",
      "side": 1,
      "message": "In the project I linked, I have non instrumented unit tests for that code which pass, because if not run on Android, an exception is thrown when accessing `Looper`, which is caught to use `Dispatchers.Main` instead. You can try simply with this snippet:\n```\ninternal val Dispatchers.MainAndroid: MainCoroutineDispatcher get() \u003d androidMainDispatcher\nprivate val androidMainDispatcher: MainCoroutineDispatcher \u003d runCatching {\n    Handler(Looper.getMainLooper()).asCoroutineDispatcher(\"androidx-main-dispatcher\")\n}.getOrElse { Dispatchers.Main }\n```",
      "parentUuid": "a9b902f1_b7a874e3",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "935eb6c3_0a9da0fa",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-28T06:55:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8b1638ae_c3ad3914",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4204b7f5_3b0b553f",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1014545
      },
      "writtenOn": "2019-01-30T21:34:45Z",
      "side": 1,
      "message": "We\u0027ve gone back and forth on this with some of the patterns we want to encourage, specifically around split async/await calls made on the raw lifecycle scope from non-suspending contexts. I\u0027m a bit worried about losing errors from defaulting to Supervisor here, but the benefits seem to outweigh the downsides given the widely-scoped nature of this coroutinescope.",
      "parentUuid": "13339b66_08948d26",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d504f758_c8bdf097",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-30T21:35:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "13339b66_08948d26",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "64701659_db5a7758",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 54,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T07:37:40Z",
      "side": 1,
      "message": "Could/should accept a `minimumState` parameter of type `Lifecycle.State` to support scopes for STARTED state, and also for RESUMED state (although I think it should be discouraged because of multi-window).",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c74ccc2e_7a2c2f86",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 54,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-28T06:55:43Z",
      "side": 1,
      "message": "it is internal right now. if we decide to provide scopes more than CREATED, we can consider that. \nIt is probably better to not add that for this CL (since it is already fairly big)",
      "parentUuid": "64701659_db5a7758",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c6481238_0720390c",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 58,
      "author": {
        "id": 1232209
      },
      "writtenOn": "2019-01-23T21:45:04Z",
      "side": 1,
      "message": "If you want you can move this into the constructor if you change the argument name\n\n    internal class LifecycleCoroutineScope(\n      private val lifecycle: Lifecycle,\n      override val coroutineContext: CoroutineContext\n    ) : CoroutineScope, LifecycleEventObserver {",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30fb732b_39a10f42",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 58,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "sgtm, will do.",
      "parentUuid": "c6481238_0720390c",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a705c2a4_706dda7e",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 58,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-28T06:55:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "30fb732b_39a10f42",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "156651d4_e317a773",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 70,
      "author": {
        "id": 1434600
      },
      "writtenOn": "2019-01-23T10:38:32Z",
      "side": 1,
      "message": "`Dispatchers.Main.immediate` can save you a dispatch when a scope is initialized from the main thread",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "175207d9_f204f4c5",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 70,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "we\u0027ll need to wait until it is out of `ExperimentalCoroutinesApi` since people may update coroutines w/o updating this library. I\u0027ll put a TODO for it",
      "parentUuid": "156651d4_e317a773",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7233a166_ba8e0048",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 70,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-28T06:55:43Z",
      "side": 1,
      "message": "added a TODO.",
      "parentUuid": "175207d9_f204f4c5",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a1da72d_5f8c86c9",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1434600
      },
      "writtenOn": "2019-01-23T10:38:32Z",
      "side": 1,
      "message": "Empty KDoc",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edaab097_045517bb",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "sorry this is not final yet, we\u0027ll add docs and all with methods (created, started, resumed)",
      "parentUuid": "1a1da72d_5f8c86c9",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eef792fd_ba45c2bb",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-28T06:55:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "edaab097_045517bb",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2be0011c_b5ba9464",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 90,
      "author": {
        "id": 1434600
      },
      "writtenOn": "2019-01-23T10:38:32Z",
      "side": 1,
      "message": "It is the question of Androidx conventions for sure, so my comment may be irrelevant.\n\nHave you considered making it (and the rest of methods) an extension on lifecycle? \n`lifecycle.withStarted { ... }` is (arguably) a bit more natural than `withStarted(lifecycle) {}`",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d46a87a0_663220d7",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 90,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T00:33:57Z",
      "side": 1,
      "message": "Following replacement of `withStateAtLeast` by `awaitState`, I\u0027d drop this to make the API surface simpler, or rename it to `awaitStarted()` otherwise.",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8785895c_2c458a1b",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 90,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "it was the initial implementation actually :). then we decided it is better off by being withStarted(lifecycle) to look closer to withContext. wdyt?",
      "parentUuid": "2be0011c_b5ba9464",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f79587d8_0c470d74",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 90,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "yea we werent sure whether we want to open withStateAtLeast or not, then decided to open it as it might make util development easier if there is some code that wants to receive a lifecycle and a state.",
      "parentUuid": "d46a87a0_663220d7",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0de67a30_e0f727a6",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 116,
      "author": {
        "id": 1232209
      },
      "writtenOn": "2019-01-23T21:45:04Z",
      "side": 1,
      "message": "The style guide says that type parameters should either be single capital letters or PascalCase suffixed with \"T\". I.e., T or ReturnT\n\nhttps://developer.android.com/kotlin/style-guide#type_variable_names",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd84e723_dd5dcd5e",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 116,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T00:33:57Z",
      "side": 1,
      "message": "I find this method confusing. Given the use case, which is running some code when the lifecycle state is at least the state that has been passed as parameter, being a both a suspend function and taking a lambda that is run before resuming is IMHO highly likely to cause confusion.\nIn addition, being top level for this would pollute autocompletion for all the places where you don\u0027t have and don\u0027t need a lifecycle.\n\nI suggest the following replacement: an extension function for Lifecycle (and Lifecycle only, no LifecycleOwner shortcut) named `awaitState`.\nThe signature would be `suspend fun Lifecycle.awaitState(state: Lifecycle.State)`. With such a replacement, there\u0027s no ambiguity, it will resume when the state has been reached. I think it fits much better into coroutines, with no unnecessary lambda.\n\nI already implemented it and it is open source, feel free to reuse my code, here\u0027s a permalink to the line: https://github.com/LouisCAD/Splitties/blob/8a38de6131b1b41d5404c8f236204cfa7becc3b8/lifecycle-coroutines/src/main/kotlin/splitties/lifecycle/coroutines/LifecycleAwaitState.kt#L26-L50",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4d56c6ec_79cac208",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 116,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "that won\u0027t work since block might be suspended and state might change meanwhile.\n\ne.g. this wont work:\n\n```\nwithContext(IO) {\n    val data \u003d fetchSomeData()\n    withContext(MAIN) {\n        awaitStarted() // afaik, there is no guarantee that when this returns, \n                       // lifecycle has not moved beyond started\n        if (data.registered()) {\n            navigateToBar()\n        }\n    }\n}\n```",
      "parentUuid": "dd84e723_dd5dcd5e",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eab2aad0_788d29f1",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 116,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "sgtm; will move to T",
      "parentUuid": "0de67a30_e0f727a6",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7cdd0a80_7b333a26",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 116,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T07:37:40Z",
      "side": 1,
      "message": "I don\u0027t think this snippet would work with `withStateAtLeast` either because if cancelled, then the `CancellationException` would be thrown anyway.\n\nAlso, the purpose of `withContext` is very different from this use case, so IMHO, there\u0027s no reason to attempt to mimic its signature. What should be provided instead is a way to create scopes that are cancelled when the lifecycle is no longer at least a state, that\u0027s the purpose of coroutine scopes.\n\nI thought about this in the past, and wrote an extension with this signature: `fun Lifecycle.createJob(activeWhile: Lifecycle.State \u003d INITIALIZED): Job`, plus another one to create the scope: `fun Lifecycle.createScope(activeWhile: Lifecycle.State): CoroutineScope`.\nYou can see how I implemented it there: https://github.com/LouisCAD/Splitties/blob/8a38de6131b1b41d5404c8f236204cfa7becc3b8/lifecycle-coroutines/src/main/kotlin/splitties/lifecycle/coroutines/Lifecycle.kt#L34-L67\nFYI, this code was initially meant to become an integration of kotlinx.coroutines (after Roman Elizarov from Kotlin team at JetBrains suggested me to start it from a gist I shared in Kotlin Slack back when coroutines were still experimental just after release of version 0.26.1 with structured concurrency), and I wrote it with that in mind, but eventually added it to a library and closed the PR as your colleague Sergey Vasilinets said they were planning to have it in AndroidX.\n\nNote that `awaitState` resumes if the state is at least the one passed in parameter, so as long as the lifecycle is not destroyed first, it suspends and resumes as soon as there\u0027s a lifecycle change that makes is at least the passed state. I should rename the parameter to `minimumState`.\n\nTaking this into account, what do you think now?",
      "parentUuid": "4d56c6ec_79cac208",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e67773c3_58947dca",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 116,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T17:21:36Z",
      "side": 1,
      "message": "The version we have here receives a non-suspend function and immediately called when you reach to a desired state. Since it is on the Main thread, the lifecycle cannot change before the block returns.\n\nOn the example you have, awaitStarted() will return as soon as we reach to started state, yet lifecycle can go back to stopped state before the next line executes, hence it will provide no guarantee that the await does what is expected. \n\nLmk if it is not clear, i can try to draw something when i get time.\n\nALso, we are aware of that bug (thanks!). As sergey mentioned, we prefer to have them in AndroidX since we write all other integrations here (and it kind of makes sense to be in sister ktx packages of original artifacts).",
      "parentUuid": "7cdd0a80_7b333a26",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "39856e5e_e274c71d",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 116,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T22:52:25Z",
      "side": 1,
      "message": "Your explanation makes it clearer to me, I understand the rationale behind.\nI still find having a function that suspends the caller, yet takes a lambda to run synchronously on a specify thread before resuming is confusing, although I may be biased as I\u0027ve used coroutines extensively since Kotlin 1.1.\nAs I said earlier, I think you should satisfy this use case with a function with the following signature `fun Lifecycle.createScope(activeWhile: Lifecycle.State): CoroutineScope` (or an alternative if you find a better one) because I find it more explicit (do you need explanations on what it does beyond the signature?), and I find it to integrate correctly in coroutines, as it cancels all coroutines from the scope as soon as the state of the lifecycle is lower than the activeWhile, regardless of the dispatcher or the thread the coroutines are running on.\n\nIn my experience, `createScope` and `awaitState` fulfilled all my lifecycle/coroutine related use cases across multiple projects, and I don\u0027t see how I\u0027d use the block from that `withStateAtLeast` function.\n\nI think it makes sense to have this integration into AndroidX too. For example, you don\u0027t need to mess with a MutableMap to cache the lifecycle job/scope here in AndroidX.",
      "parentUuid": "e67773c3_58947dca",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d23faf95_e336c5aa",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 116,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-28T06:55:43Z",
      "side": 1,
      "message": "We\u0027ll discuss internally but I\u0027m worried that that API might mislead people (they might hope it will start running again after stop/start cycle).\nOver the years, we\u0027ve had more success in limiting things. It sucks for more advanced use cases but makes the APIs much easier to understand for the greater pool.\n\nThat being said, nothing really prevents us from providing an API to create a scope hence we might do both (have lifecycle that goes between create-destroy as default, then allow people create their own if they want).\n\nBtw, the original idea I had was to have a scope that automatically suspends if lifecycle goes out of scope (via a custom dispatcher). We\u0027ve ditched that idea for being too magical.",
      "parentUuid": "39856e5e_e274c71d",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31e836c9_2ba92b24",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 116,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-28T06:55:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "eab2aad0_788d29f1",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "736c830f_a50575b8",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 116,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-30T21:35:16Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "d23faf95_e336c5aa",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7dcbd1ef_5ec5984e",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 122,
      "author": {
        "id": 1232209
      },
      "writtenOn": "2019-01-23T21:45:04Z",
      "side": 1,
      "message": "This should be outside `withContext` so that you get a readable stacktrace with user code when it fails instead of one that points at `Looper.loop`",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3014775_296e6708",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 122,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "sgtm, will do.",
      "parentUuid": "7dcbd1ef_5ec5984e",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a736722_4077ae4b",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 122,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-30T21:35:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a3014775_296e6708",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4358155e_b2409267",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 142,
      "author": {
        "id": 1434600
      },
      "writtenOn": "2019-01-23T10:38:32Z",
      "side": 1,
      "message": "This can be simplified to `cancellable.resumeWith(runCatching{ block() })`",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a14cd46_918b87f2",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 142,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "sgtm, will do.",
      "parentUuid": "4358155e_b2409267",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2031a4d_e42a1ce6",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt",
        "patchSetId": 14
      },
      "lineNbr": 142,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-28T06:55:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7a14cd46_918b87f2",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a8806c15_e6f7c762",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/LifecycleOwner.kt",
        "patchSetId": 14
      },
      "lineNbr": 29,
      "author": {
        "id": 1099237
      },
      "writtenOn": "2019-01-24T00:33:57Z",
      "side": 1,
      "message": "Shouldn\u0027t this property be inline given how trivial is its getter? Remember in some projects that are near the multidex limit, each method counts, because only one can make it overflow.\n\nI assume this would mainly be used directly from subclasses, so it would look like this: `lifecycleScope.launch { ... }`.\n\nHaving `lifecycle` in the name is good because it removes ambiguity about the coroutine scope source.\n\nHowever, if the `lifecycleScope` extension for the `Lifecycle` class is renamed to `coroutineScope` or `mainScope` following my suggestion, shouldn\u0027t this one be renamed accordingly to `lifecycleCoroutineScope` or `lifecycleMainScope`? I know this is longer, but I believe being explicit (and consistent) takes precedence, and one can always use named import or an inline extension with any name.",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67f390e9_a13046f0",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/LifecycleOwner.kt",
        "patchSetId": 14
      },
      "lineNbr": 29,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "might be, will discuss; thanks!",
      "parentUuid": "a8806c15_e6f7c762",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "76754267_b00c08c5",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/LifecycleOwner.kt",
        "patchSetId": 14
      },
      "lineNbr": 39,
      "author": {
        "id": 1434600
      },
      "writtenOn": "2019-01-23T10:38:32Z",
      "side": 1,
      "message": "Extra indent",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b0ef17c_607faf43",
        "filename": "lifecycle/common/ktx/src/main/java/androidx/lifecycle/LifecycleOwner.kt",
        "patchSetId": 14
      },
      "lineNbr": 39,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "Ack, not sure why ktlint didn\u0027t catch that :/",
      "parentUuid": "76754267_b00c08c5",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2bf078e0_e80e5344",
        "filename": "lifecycle/common/src/main/java/androidx/lifecycle/Lifecycle.java",
        "patchSetId": 14
      },
      "lineNbr": 87,
      "author": {
        "id": 1232209
      },
      "writtenOn": "2019-01-23T21:45:04Z",
      "side": 1,
      "message": "+final",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "966d43af_acc79dfd",
        "filename": "lifecycle/common/src/main/java/androidx/lifecycle/Lifecycle.java",
        "patchSetId": 14
      },
      "lineNbr": 87,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-01-24T02:25:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "2bf078e0_e80e5344",
      "revId": "65cac67fee56288d6f03858420c73c03a9db2a19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}