{
  "comments": [
    {
      "key": {
        "uuid": "cd5f43c6_de7b482d",
        "filename": "lifecycle/livedata/eap/src/main/java/androidx/lifecycle/CoroutineLiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 30,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-02-28T19:26:57Z",
      "side": 1,
      "message": "sergey: consider https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence-scope/index.html",
      "range": {
        "startLine": 30,
        "startChar": 10,
        "endLine": 30,
        "endChar": 23
      },
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7091943_5b0724b4",
        "filename": "lifecycle/livedata/eap/src/main/java/androidx/lifecycle/CoroutineLiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 30,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-03-01T22:14:29Z",
      "side": 1,
      "message": "I cannot use it because it has a private constructor. the impl of it,SequenceBuilderIterator, is also private. :/",
      "parentUuid": "cd5f43c6_de7b482d",
      "range": {
        "startLine": 30,
        "startChar": 10,
        "endLine": 30,
        "endChar": 23
      },
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5d2e643d_ba4dedd2",
        "filename": "lifecycle/livedata/eap/src/main/java/androidx/lifecycle/CoroutineLiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 36,
      "author": {
        "id": 1014545
      },
      "writtenOn": "2019-02-28T23:56:46Z",
      "side": 1,
      "message": "why nullable?",
      "range": {
        "startLine": 36,
        "startChar": 34,
        "endLine": 36,
        "endChar": 37
      },
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56440a44_a40e7a39",
        "filename": "lifecycle/livedata/eap/src/main/java/androidx/lifecycle/CoroutineLiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 36,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-03-01T22:14:29Z",
      "side": 1,
      "message": "ugh, i used to clear it but don\u0027t need anymore. reverted to non-null.",
      "parentUuid": "5d2e643d_ba4dedd2",
      "range": {
        "startLine": 36,
        "startChar": 34,
        "endLine": 36,
        "endChar": 37
      },
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0a1fe6f7_6c7783e1",
        "filename": "lifecycle/livedata/eap/src/main/java/androidx/lifecycle/CoroutineLiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 74,
      "author": {
        "id": 1376662
      },
      "writtenOn": "2019-02-28T21:34:14Z",
      "side": 1,
      "message": "This is really nice. Not requiring a Scope to call this function makes it quite easy to use.\n\nA common use case for this will be to transform data in the Repository layer, where injecting viewModelScope creates boilerplate.",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05da749f_e741c617",
        "filename": "lifecycle/livedata/eap/src/main/java/androidx/lifecycle/CoroutineLiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 81,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-02-28T19:26:57Z",
      "side": 1,
      "message": "we can remove this one.",
      "range": {
        "startLine": 80,
        "startChar": 11,
        "endLine": 81,
        "endChar": 9
      },
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32acfdc8_95a285b8",
        "filename": "lifecycle/livedata/eap/src/main/java/androidx/lifecycle/CoroutineLiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 88,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-02-28T19:26:57Z",
      "side": 1,
      "message": "sergey: we can play unsafe and immediately remove w/o thread jump since we are the only ones using this MLD and add always happens before remove.",
      "range": {
        "startLine": 84,
        "startChar": 2,
        "endLine": 88,
        "endChar": 5
      },
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd4bbceb_8f1811fb",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/CoroutineLiveDataSwitchMapTest.kt",
        "patchSetId": 7
      },
      "lineNbr": 39,
      "author": {
        "id": 1376662
      },
      "writtenOn": "2019-02-28T21:34:14Z",
      "side": 1,
      "message": "Passing the default context via the suspend function mechanism and possibly allowing an optional parameter might be a simpler API.\n\nCompare:\n\n```\nsuspend fun suspendContext() {\n    src.switchMap { yield(0) }  // use existing context implicitly\n\n    withContext(Dispatchers.Default) {\n        src.switchMap { yield(1) }  // use existing context modified by withContext\n    }\n\n    src.switchMap(Dispatchers.Default) { yield(2) } // pass an explicit context\n}\n```\n\n```\nsuspend fun parameterContext() {\n    src.switchMap(coroutineContext) { yield(0) }\n    \n    withContext(Dispatchers.Default) {\n        src.switchMap(coroutineContext) { yield(1) }\n    }\n\n    src.switchMap(Dispatchers.Default) { yield(3) }\n}\n```",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "554d20ab_1e9e50b0",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/CoroutineLiveDataSwitchMapTest.kt",
        "patchSetId": 7
      },
      "lineNbr": 39,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-03-01T22:14:29Z",
      "side": 1,
      "message": "to do that, we would need to make `switchMap` a suspend function. but then you cannot use it as follows:\n\n\n    class ViewModel {\n        val user  \u003d userId.switchMap(viewModelScope.coroutineContext ) {\n              yield(db.load(it))\n        }\n    }",
      "parentUuid": "dd4bbceb_8f1811fb",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ddd0b2e_19676693",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/CoroutineLiveDataSwitchMapTest.kt",
        "patchSetId": 7
      },
      "lineNbr": 39,
      "author": {
        "id": 1376662
      },
      "writtenOn": "2019-03-01T22:38:36Z",
      "side": 1,
      "message": "Ah, I see the goal is to return the LiveData. That\u0027s a really compelling use case that I can see using all the time.\n\nWorking through the implications of this invocation:\n\n1. When already in a suspend function, the idiomatic `withContext|async|launch` style invocation breaks structured concurrency. E.g.\n\n```\nsusupend fun foo() {\n    ld.switchMap(Dispatchers.Default) { // parent scope is discarded }\n}\n```\n\n2. It\u0027s a bit awkward to invoke, enough that I\u0027d probably put an extension on ViewModel in real code to do the right thing:\n\n```\nfun \u003cT\u003e ViewModel.switchMapFrom(ld: LiveData\u003cT\u003e, context: CoroutineContext \u003d EmptyCoroutineContext, block: (LiveDataScope\u003cT\u003e) -\u003e Unit) {\n    val newContext \u003d viewModelScope.coroutineContext + context\n    ld.switchMap(newContext, block) \n}\n```\n\nContinuing down that line of thought, what do you think about this invocation?\n\n```\nclass ViewModel {\n   val user \u003d TransformationsAsync.switchMap(userId) { // default correct, stays on main }\n   val heavilyProcessedList \u003d TransformationsAsync.switchMap(databaseList, Dispatchers.Default) { // still respects viewModelScope, but now on Dispatchers.Default }}\n}\n\nclass Repository {\n   // TransformationsAsync is an extension of ViewModel, so not available here)\n\n   suspend fun foo() \u003d roomQuery().switchMap { // on dispatcher of `foo` caller }\n   suspend fun bar() \u003d roomQuery().switchMap(Dispatchers.Default) { // scope respected, Dispatchers.Default }\n```\n\nAPI definitely needs some more thought, but the idea to evaluate is making structured concurrency the default even in the presence of the scope management by `switchMap`",
      "parentUuid": "554d20ab_1e9e50b0",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10e9dab3_806257f0",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/CoroutineLiveDataSwitchMapTest.kt",
        "patchSetId": 7
      },
      "lineNbr": 39,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-03-04T01:14:53Z",
      "side": 1,
      "message": "at this point, we do not have a use case for creating a LiveData on a background thread.\nif room query returns LiveData, it can be called on the main thread and most use cases, initializing a VM, already happens on the main thread (not in a suspension).\n\nWe do not really want people to create chain of switchMap calls actually (this is not memory cheap), we want them to just run them in a coroutine and calculate the value (which is why the block is suspend, they can do anything async for 1 shot ops)\n\nWe can look into it if there are legit use cases where a LiveData instance needs to be computed on a background thread and we might provide `yield\u003cLiveData\u003cT\u003e\u003e` for those. \nwdyt?",
      "parentUuid": "2ddd0b2e_19676693",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6da1bb1a_dea0e6ad",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/CoroutineLiveDataSwitchMapTest.kt",
        "patchSetId": 7
      },
      "lineNbr": 39,
      "author": {
        "id": 1376662
      },
      "writtenOn": "2019-03-04T20:11:02Z",
      "side": 1,
      "message": "Makes sense to me to prefer calling this ~once and doing logic inside the coroutine.\n\nWhat would the API `yield\u003cLiveData\u003cT\u003e\u003e` would look like?\n\nI\u0027m still a bit concerned the current exposes a footgun in it\u0027s current form since it\u0027s easy to drop the Job and CoroutineExceptionHandler when used from inside a suspend function. Given the similarity of invocation between the following and `withContext` I expect it will confuse developers.\n\n```\nsuspend fun transformSrc(src: LiveData\u003cFoo\u003e) \u003d src.switchMap(Dispatchers.Default) {\n        // runs after transformSrc\u0027s Job is cancelled\n        // uncaught exceptions trigger thread\u0027s uncaught exception handler\n    }\n}\n```\n\nLooking at this API for use cases that want the coroutine body on a background thread (almost all related to RV list processing)\n\n1) Combining multiple list sources (to populate a RV).\n2) Filtering a list source (this *can* be moved to the database, but it\u0027s often easier to put the logic in code)\n3) Transforming a list between types (this creates a lot of extra work, but in some architectures for large teams it helps make combining multiple things into a RV easy without sharing the details all the way to the data layer [read: developer efficiency over execution efficiency])\n4) Transforming a data list with display logic (common use cases for RV: inserting ads, headers, hiding or modifying rows, horizontal sections with other lists, etc)\n\nHere\u0027s an example from IOSched of filtering logic being applied to a list in code https://github.com/google/iosched/blob/master/shared/src/main/java/com/google/samples/apps/iosched/shared/domain/sessions/LoadUserSessionUseCase.kt#L46\n\nFrom a code structure perspective, a lot of developers prefer to keep this logic somewhere other than inline in the ViewModel since when applied to several flows on a screen it can end up making ViewModel\u0027s large (e.g. a UseCase, Repository, or other patterns)\n\nWorking through an example of how all of these might be applied (mostly so I can figure out how this would work) both with everything in a ViewModel, and using a UseCase or Repository to do the transformation leads me to this code:\n\n```\nclass ViewModel {\n   val liveData \u003d someSource(\"query\").switchMap(liveDataScope.coroutineContext) { items: List\u003cFoo\u003e -\u003e \n       yield(withContext(Dispatchers.Default) {\n            // combine a second source\n            // needs a MediatorLiveData\n\n            val filtered \u003d items.filter { // predicate }\n            val transformed \u003d filtered.map { OtherType.from(it) }\n            val withHeadersAndAds \u003d listOf(Header) + transformed + listOf(Ad)\n            listOfHeadersAndAds\n      }\n}\n\nAnd moving this to something like a Repository or UseCase this is pretty compelling:\n\nclass ViewModel {\n    val liveData \u003d someSource(\"query\").switchMap(liveDataScope.coroutineContext) { UseCase.suspendingTransform(it) }\n}\n\nclass UseCase {\n    // Note: this is easier to test than an impl. that interacts with LiveData at this layer\n    suspend fun suspendingTransform(items: List\u003cFoo\u003e): List\u003cOtherType\u003e {\n        withContext(Dispatchers.Default) {\n            val filtered \u003d items.filter { // predicate }\n            val transformed \u003d filtered.map { OtherType.from(it) }\n            val withHeadersAndAds \u003d listOf(Header) + transformed + listOf(Ad)\n            listOfHeadersAndAds\n        }\n    }\n}\n\nAfter working that example, the control flow for the UseCase version ends up pretty similar to RX (come up to VM - bounce down to logic in UseCase | Repository - back up to VM). The code style of streaming transform inside the UseCase or Repository layer could be discouraged by requiring a `CoroutineScope` as a parameter to `switchMap`.\n\nSimilarly, it might make sense to for `switchMap` to force dispatch on `Dispatchers.Main` since anything else would already creates (hidden from the developer) thread switches per invocation and yield? That would limit the possible usages of this API, encouraging developers to use it in ViewModel and delegate to `Dispatchers.Main` safe suspending functions.\n\nWDYT?",
      "parentUuid": "10e9dab3_806257f0",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e4a3b15_4d057dd9",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/LiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1376662
      },
      "writtenOn": "2019-02-28T21:34:14Z",
      "side": 1,
      "message": "This API surprises me compared to exposing an iterator similar to:\n\nhttps://github.com/Kotlin/kotlin-coroutines-examples/blob/master/examples/suspendingSequence/suspendingSequence.kt#L14\n\nCompare;\n\n```\nfor(value in liveData.asyncIterator) {\n}\n\nliveData.asyncIterator.map { something}\n// etc\n```\n\n(with cleanup handled by CoroutineScope cancellation)\n\n\n// vs nextValueAsync()\n```\nfor(value in liveData.nextValueAsync()) {\n}\n```\n\nIs this for testing or production usage?",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4eec3334_407b7869",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/LiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-03-01T22:14:29Z",
      "side": 1,
      "message": "just for testing for now. \n\nCould be a public API as i think it is useful  but not the intend right now.\nThe key here is to skip existing value (since live data may already have an existing value).",
      "parentUuid": "1e4a3b15_4d057dd9",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c4eb8ede_d4537c9b",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/LiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 34,
      "author": {
        "id": 1014545
      },
      "writtenOn": "2019-02-28T23:56:46Z",
      "side": 1,
      "message": "a suspend api that returns Deferred is super weird",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e65f8458_aa7c548f",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/LiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 34,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-03-01T22:14:29Z",
      "side": 1,
      "message": "it returns deferred because i want to control the time where it started observing. It is suspend becacuse it must start observing before returning.",
      "parentUuid": "c4eb8ede_d4537c9b",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8151692_4fed4131",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/LiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 49,
      "author": {
        "id": 1014545
      },
      "writtenOn": "2019-02-28T23:56:46Z",
      "side": 1,
      "message": "I would expect this to return def.await() and the function to return T instead",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94586e4a_9fc7dce0",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/LiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 49,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-03-01T22:14:29Z",
      "side": 1,
      "message": "it cannot because i want it to return after starting to observe.\n\nuse case looks like this:\n\nval items \u003d liveData.collect(2)\nliveData.value \u003d 1\nliveData.value \u003d 2\nassertThat(items.await()).hasItems(1,2)\n\nIf it returns before observing, value 1 might be overwritten by value 2.\nif it await, then i cannot set the value.",
      "parentUuid": "b8151692_4fed4131",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4c7e3414_e665663c",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/LiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 56,
      "author": {
        "id": 1014545
      },
      "writtenOn": "2019-02-28T23:56:46Z",
      "side": 1,
      "message": "same here, Deferred is super weird to return from a suspend fun",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "01ddf88f_2b3c1ebb",
        "filename": "lifecycle/livedata/eap/src/test/java/androidx/lifecycle/LiveData.kt",
        "patchSetId": 7
      },
      "lineNbr": 56,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-03-01T22:14:29Z",
      "side": 1,
      "message": "see explanation above.",
      "parentUuid": "4c7e3414_e665663c",
      "revId": "1ac2159690e38d434cf8e65e13862c96a73b8756",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}