{
  "comments": [
    {
      "key": {
        "uuid": "9a2bc7c9_5ac03a92",
        "filename": "fragment/java/android/support/v4/app/FragmentPagerAdapter.java",
        "patchSetId": 4
      },
      "lineNbr": 136,
      "author": {
        "id": 1014545
      },
      "writtenOn": "2017-01-27T16:19:12Z",
      "side": 1,
      "message": "This isn\u0027t the right layer to be taking this into account. If the parent isn\u0027t visible by these rules, it shouldn\u0027t matter that the child fragment is setting these things. It looks like this is hiding another issue elsewhere.",
      "revId": "388819c3b343f7aa30afcd8a237d012382ca6d80",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c56e5ea9_318795d1",
        "filename": "fragment/java/android/support/v4/app/FragmentPagerAdapter.java",
        "patchSetId": 4
      },
      "lineNbr": 136,
      "author": {
        "id": 1056338
      },
      "writtenOn": "2017-01-27T16:46:18Z",
      "side": 1,
      "message": "I\u0027m not sure that I understand what you\u0027re saying in your second sentence. Currently, with a ViewPager inside a not-visible Fragment, the contents of that ViewPager cannot trust getUserVisibleHint() to be accurate. Is getUserVisibleHint only intended to mean visible relative to its parent Activity or Fragment, but not necessarily visible overall to the user?",
      "revId": "388819c3b343f7aa30afcd8a237d012382ca6d80",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "79b261c3_66e6fa4c",
        "filename": "fragment/java/android/support/v4/app/FragmentPagerAdapter.java",
        "patchSetId": 4
      },
      "lineNbr": 136,
      "author": {
        "id": 1014545
      },
      "writtenOn": "2017-01-27T17:45:16Z",
      "side": 1,
      "message": "It means, \"return the value set by setUserVisibleHint,\" so yes, it\u0027s highly localized to just that one fragment.\n\nWhat are you using it for?",
      "revId": "388819c3b343f7aa30afcd8a237d012382ca6d80",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7549ca8c_758760ab",
        "filename": "fragment/java/android/support/v4/app/FragmentPagerAdapter.java",
        "patchSetId": 4
      },
      "lineNbr": 136,
      "author": {
        "id": 1056338
      },
      "writtenOn": "2017-01-27T18:53:18Z",
      "side": 1,
      "message": "I have a ViewPager with FragmentPagerAdapter. The second, offscreen (Fragment) item of that ViewPager, has itself a ViewPager, with another FragmentPagerAdapter. When the top-level ViewPager is initialized, and that second item is offscreen, and not visible, it initializes its ViewPager and sets the first item as visible, even though it is not. I\u0027m using a combination of getUserVisibleHint() and isResumed() to determine refreshing content when a user returns to a page. This results in the nested ViewPager\u0027s first item refreshing when it\u0027s not visible.",
      "revId": "388819c3b343f7aa30afcd8a237d012382ca6d80",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bb5eef56_debd6cf6",
        "filename": "fragment/java/android/support/v4/app/FragmentPagerAdapter.java",
        "patchSetId": 4
      },
      "lineNbr": 136,
      "author": {
        "id": 1056338
      },
      "writtenOn": "2017-01-30T13:55:06Z",
      "side": 1,
      "message": "The FragmentPagerAdapter causes the following code in a Fragment implementation to behave unpredictably\n\n@Override\npublic void onResume() {\n    super.onResume();\n\n    if (getUserVisibleHint()) {\n        // show the user new content or animations\n    }\n}\n\n@Override\npublic void setUserVisibleHint(boolean isVisible) {\n    super.setUserVisibleHint(isVisible);\n\n    if (isResumed()) {\n        // show the user new content or animations\n    }\n}\n\nI suppose another way for this to be handled would be for Fragment to ignore calls to setUserVisibleHint(true) if it has a parent which is not visible. However, that would not prevent implementations overriding the method from receiving the spurious call. What do you think about that?",
      "revId": "388819c3b343f7aa30afcd8a237d012382ca6d80",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "52c28e53_c73ab125",
        "filename": "fragment/java/android/support/v4/app/FragmentPagerAdapter.java",
        "patchSetId": 4
      },
      "lineNbr": 136,
      "author": {
        "id": 1014545
      },
      "writtenOn": "2017-02-01T00:53:00Z",
      "side": 1,
      "message": "I think I regret not making setUserVisibleHint final from the beginning. :)\n\nI see the need for something like this, but I think fragments need a more encapsulated way to do it that doesn\u0027t leak across parent/child fragment boundaries. There\u0027s a need for fragments to find out about aggregate user visibility changes that take into account the parent chain, but I don\u0027t want each individual fragment to have to do this manually or to not be able to get the value they directly set on a fragment back out unchanged.",
      "revId": "388819c3b343f7aa30afcd8a237d012382ca6d80",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f37f847_1b38e588",
        "filename": "fragment/java/android/support/v4/app/FragmentPagerAdapter.java",
        "patchSetId": 4
      },
      "lineNbr": 136,
      "author": {
        "id": 1056338
      },
      "writtenOn": "2017-02-01T01:00:18Z",
      "side": 1,
      "message": "It occurs to me that this proposed change would only surface the issue that the parent later becoming visible would not propagate down to its children. And how could it properly? Keeping it hyperlocal makes the most sense at this point.",
      "revId": "388819c3b343f7aa30afcd8a237d012382ca6d80",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}