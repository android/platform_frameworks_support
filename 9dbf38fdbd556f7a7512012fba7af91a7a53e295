{
  "comments": [
    {
      "key": {
        "uuid": "d841380c_72e4d810",
        "filename": "room/integration-tests/testapp/src/androidTest/java/androidx/room/integration/testapp/test/RxJava2Test.java",
        "patchSetId": 2
      },
      "lineNbr": 688,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-06-06T19:44:54Z",
      "side": 1,
      "message": "assertCompleted ?",
      "range": {
        "startLine": 688,
        "startChar": 21,
        "endLine": 688,
        "endChar": 35
      },
      "revId": "9dbf38fdbd556f7a7512012fba7af91a7a53e295",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "077d00fa_6b3de3e5",
        "filename": "room/integration-tests/testapp/src/androidTest/java/androidx/room/integration/testapp/test/RxJava2Test.java",
        "patchSetId": 2
      },
      "lineNbr": 688,
      "author": {
        "id": 1258207
      },
      "writtenOn": "2019-06-06T23:48:02Z",
      "side": 1,
      "message": "The stream doesn\u0027t receive any complete signals ended up asserting not terminated. However, while adding that check I noticed newer RxJava had a tryOnError that basically attempts to propagate the error if the stream is not yet disposed, just what we wanted so ended up upgrading Rx (and importing into prebuilts) to use it. Also had to update a bit the tests because the singleFromCallable_emptyResult_disposed() test caused an UndeliverableException just like in non-test-world, so asseting on the error is different.",
      "parentUuid": "d841380c_72e4d810",
      "range": {
        "startLine": 688,
        "startChar": 21,
        "endLine": 688,
        "endChar": 35
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "9dbf38fdbd556f7a7512012fba7af91a7a53e295",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}