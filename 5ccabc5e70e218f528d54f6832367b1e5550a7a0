{
  "comments": [
    {
      "key": {
        "uuid": "7183fe8a_4344e2f7",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 91,
      "author": {
        "id": 1060493
      },
      "writtenOn": "2019-06-18T21:54:22Z",
      "side": 1,
      "message": "This method is pretty long. Can you break it up in a meaningful way?",
      "range": {
        "startLine": 91,
        "startChar": 30,
        "endLine": 91,
        "endChar": 37
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5fcdfb94_a93837fb",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 91,
      "author": {
        "id": 1344416
      },
      "writtenOn": "2019-06-18T23:49:00Z",
      "side": 1,
      "message": "3 things:\n\n1. Actually, I think my comments are long.  Algorithms are hard and I spent a while making sure that the code was as simple as I could make it (and didn\u0027t have any weird, harder than necessary to follow, code) but I still wanted to back it up with comments to explain why things were happening the way they were.. so there are a lot of long comments.\n\n2. I actually think that breaking long methods into sub methods may do more harm than good because it may make code paths harder to reason about.  If I look at a class with 3 long methods, it doesn\u0027t take long at all to determine the enumeration of possible code paths, but if I see a class with 9 methods, the only way to really reason about code paths is to do the research to see which methods are calling which ones where (which is a complexity that I hate running into when I read code).  I think methods should only be broken out when it actually makes sense to reuse the method (in which case the complexity of doing so is called for).\n\n3. I added more comments, haha, with Step 1, 2, and 3, titles to make it clear how one can conceptually think of the algorithm.",
      "parentUuid": "7183fe8a_4344e2f7",
      "range": {
        "startLine": 91,
        "startChar": 30,
        "endLine": 91,
        "endChar": 37
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e52f96db_d9126979",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 91,
      "author": {
        "id": 1060493
      },
      "writtenOn": "2019-06-19T20:44:44Z",
      "side": 1,
      "message": "Yeah, what I really meant was that I couldn\u0027t understand the method and I was hoping that by breaking it up, you\u0027d make it more readable. The docs help.\n\nThe style:\n\nval foo \u003d if (someCondition) {\n    // do a ton of stuff\n  } else {\n    somethingElse()\n  }\n\nCan be difficult to track. I have some trouble following the indentation.",
      "parentUuid": "5fcdfb94_a93837fb",
      "range": {
        "startLine": 91,
        "startChar": 30,
        "endLine": 91,
        "endChar": 37
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e0b215aa_de154609",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 91,
      "author": {
        "id": 1344416
      },
      "writtenOn": "2019-06-20T18:18:56Z",
      "side": 1,
      "message": "Yeah, I understand.  I\u0027m often torn between splitting methods out and keeping things inline (have gone back and forth a bit, but I think for now, I\u0027d like to try keeping things inline and see how that works out. :)",
      "parentUuid": "e52f96db_d9126979",
      "range": {
        "startLine": 91,
        "startChar": 30,
        "endLine": 91,
        "endChar": 37
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccc2ec8_cfd47d44",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 100,
      "author": {
        "id": 1060493
      },
      "writtenOn": "2019-06-18T21:54:22Z",
      "side": 1,
      "message": "I think you need to take into account the offset (x \u0026 y) of the layoutNode",
      "range": {
        "startLine": 100,
        "startChar": 20,
        "endLine": 100,
        "endChar": 23
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46294973_7c53293f",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 100,
      "author": {
        "id": 1344416
      },
      "writtenOn": "2019-06-18T23:49:00Z",
      "side": 1,
      "message": "It is actually taken care of at the next level up in the recursion.  I made the decision that when this method is called, I want it to be able to assume it\u0027s point of origin is 0, 0 (because the source of truth for it\u0027s position is in the parent and it should never assume it knows it\u0027s actual position relative to it\u0027s parent).  So, in the next level up, if a child is a layout node, before calling hitTest on the layout node, the positions are offset.",
      "parentUuid": "dccc2ec8_cfd47d44",
      "range": {
        "startLine": 100,
        "startChar": 20,
        "endLine": 100,
        "endChar": 23
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0aeea665_a16ad680",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1060493
      },
      "writtenOn": "2019-06-18T21:54:22Z",
      "side": 1,
      "message": "It feels like we\u0027ve made a mistake in our architecture here and elsewhere. I don\u0027t like that we have to do these instance checks. In the future let\u0027s consider multiple trees. In one tree, we\u0027ll have something that supports hitTest, just for PointerInput. In another, we have draw(). In another, we have layout(). etc.",
      "range": {
        "startLine": 134,
        "startChar": 24,
        "endLine": 134,
        "endChar": 43
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c9baa4e2_1cebf67b",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1344416
      },
      "writtenOn": "2019-06-18T23:49:00Z",
      "side": 1,
      "message": "Yeah, I think I agree.  However, in this case, I need LayoutNodes and PointerInputNodes to do hit testing.  That being said, it seems that SemanticsNode, DrawNode, and PointerInputNode all need layout information such that maybe they could be given that information during the layout phase, such that they then wouldn\u0027t need to query LayoutNodes any any following pass (such as this hit testing pass).",
      "parentUuid": "0aeea665_a16ad680",
      "range": {
        "startLine": 134,
        "startChar": 24,
        "endLine": 134,
        "endChar": 43
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "97e3324b_71abb24d",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1053203
      },
      "writtenOn": "2019-06-19T01:06:49Z",
      "side": 1,
      "message": "I\u0027m not a huge fan of this frequent type check either. It\u0027d be great to eliminate the need to do this from an architecture perspective.",
      "parentUuid": "c9baa4e2_1cebf67b",
      "range": {
        "startLine": 134,
        "startChar": 24,
        "endLine": 134,
        "endChar": 43
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "752c1f44_e0417a38",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1344416
      },
      "writtenOn": "2019-06-19T18:21:49Z",
      "side": 1,
      "message": "At the same time... what is actually bad about using instance checks, especially done in code that is only accessible to us anyway?  I understand the general OOP notion of breaking some of the flexibility of polymorphism... but I\u0027m not positive it applies in this case?\n\nThough, I am still in favor of the idea that a bunch of component nodes need sizing information, and it would be cool if they just got that for free. :)",
      "parentUuid": "97e3324b_71abb24d",
      "range": {
        "startLine": 134,
        "startChar": 24,
        "endLine": 134,
        "endChar": 43
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e7438358_48242d2d",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 168,
      "author": {
        "id": 1053203
      },
      "writtenOn": "2019-06-19T01:06:49Z",
      "side": 1,
      "message": "I\u0027d cache this outside of the recursion. Type checking is expensive.",
      "range": {
        "startLine": 168,
        "startChar": 20,
        "endLine": 168,
        "endChar": 39
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97a26e31_79df2ebc",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 168,
      "author": {
        "id": 1344416
      },
      "writtenOn": "2019-06-19T18:21:49Z",
      "side": 1,
      "message": "I\u0027m not sure how I would cache this outside of recursion. I can cache it locally such that I\u0027m doing the operation once instead of twice, however, it feels like it will complicate the code (1 of a potential 1000 cuts?) where it is already somewhat necessarily complicated.  I\u0027d prefer to hold of on optimizations until their benefit is measurable.",
      "parentUuid": "e7438358_48242d2d",
      "range": {
        "startLine": 168,
        "startChar": 20,
        "endLine": 168,
        "endChar": 39
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b3e34cf_d2d905c7",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 178,
      "author": {
        "id": 1053203
      },
      "writtenOn": "2019-06-19T01:06:49Z",
      "side": 1,
      "message": "This should probably be extracted into a separate function that does a union of two nullable rects.",
      "range": {
        "startLine": 170,
        "startChar": 0,
        "endLine": 178,
        "endChar": 25
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6db5d6b_a2913e65",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 178,
      "author": {
        "id": 1344416
      },
      "writtenOn": "2019-06-19T18:21:49Z",
      "side": 1,
      "message": "Hmm, I chatted with the Android Toolkit room and tried a few things myself, and I\u0027m not sure an extracted method will actually be helpful outside of this class and extracting the functionality out feels like it kind of just confuses things...?\n\nI do feel like the code here is verbose for the purpose of just doing 2 null checks... \n\nIt basically felt like whatever I did, the fact that 2 null checks were happening was most clear when it was inline.\n\nHappy to discuss. :)",
      "parentUuid": "3b3e34cf_d2d905c7",
      "range": {
        "startLine": 170,
        "startChar": 0,
        "endLine": 178,
        "endChar": 25
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb5eb637_be60876e",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 178,
      "author": {
        "id": 1053203
      },
      "writtenOn": "2019-06-19T21:28:07Z",
      "side": 1,
      "message": "It would help clarify what\u0027s going on in the code that I highlighted. I\u0027d do a utility function:\n\nprivate fun union(a: Rect?, b: Rect?) : Rect? {// null checks can happen in here...}\n\nIt would make this block of code easier to read for me. But of course that\u0027s up to you.",
      "parentUuid": "c6db5d6b_a2913e65",
      "range": {
        "startLine": 170,
        "startChar": 0,
        "endLine": 178,
        "endChar": 25
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a73df84c_05f879e2",
        "filename": "ui/platform/src/main/java/androidx/ui/core/pointerinput/PointerInputEventProcessor.kt",
        "patchSetId": 3
      },
      "lineNbr": 178,
      "author": {
        "id": 1344416
      },
      "writtenOn": "2019-06-20T18:18:56Z",
      "side": 1,
      "message": "I realized my argument that \"code that is intended to only be called by one code path should simply be made inline in that path\" didn\u0027t take into account methods that don\u0027t change state.  State changing methods are dangerous to make their own method because calling it from the wrong code path could create confusing bugs and code.  But if the method doesn\u0027t change state (especially if it can be external to the state holding entity) then it seems totally fine to pull it out. \n\nSo, done!",
      "parentUuid": "cb5eb637_be60876e",
      "range": {
        "startLine": 170,
        "startChar": 0,
        "endLine": 178,
        "endChar": 25
      },
      "revId": "5ccabc5e70e218f528d54f6832367b1e5550a7a0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}