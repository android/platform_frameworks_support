{
  "comments": [
    {
      "key": {
        "uuid": "00fce452_d30fad31",
        "filename": "lifecycle/runtime/eap/lint/src/main/java/androidx/lifecycle/lint/LifecycleWhenChecks.kt",
        "patchSetId": 6
      },
      "lineNbr": 221,
      "author": {
        "id": 1004689
      },
      "writtenOn": "2019-03-26T21:07:53Z",
      "side": 1,
      "message": "up to you but at least in the tools codebase we avoid capitalizing acronyms; e.g. this would be named \"checkUiAccess\".",
      "revId": "d1e9cf0554b5dd826c17a9a4d9cfc76953f4c23c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "674e625e_1517b91d",
        "filename": "lifecycle/runtime/eap/lint/src/main/java/androidx/lifecycle/lint/LifecycleWhenChecks.kt",
        "patchSetId": 6
      },
      "lineNbr": 237,
      "author": {
        "id": 1004689
      },
      "writtenOn": "2019-03-26T21:07:53Z",
      "side": 1,
      "message": "Lint checks generally do not include position information in the error message. In the text report lint will compute it from the location; in the IDE you don\u0027t want to see it, you just want the range to be highlighted.\n\nIf what you\u0027re trying to do is provide *two* error locations for an error, you can do that with the location API; call setSecondary(Location) on your primary location. (It\u0027s basically a linked list). You can add a description for each location as well. This is for example how the duplicate attribute lint check works; in the IDE, both locations are highlighted. In HTML reports, all the associated locations are listed below the error.",
      "revId": "d1e9cf0554b5dd826c17a9a4d9cfc76953f4c23c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ebd3636_e25a3943",
        "filename": "lifecycle/runtime/eap/lint/src/main/java/androidx/lifecycle/lint/LifecycleWhenChecks.kt",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 1060337
      },
      "writtenOn": "2019-03-26T18:18:32Z",
      "side": 1,
      "message": "this seems like a very common pattern for lint, Tor, is there any abstraction for such caching ?",
      "revId": "d1e9cf0554b5dd826c17a9a4d9cfc76953f4c23c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2ea65a5_4acc476f",
        "filename": "lifecycle/runtime/eap/lint/src/main/java/androidx/lifecycle/lint/LifecycleWhenChecks.kt",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 1004689
      },
      "writtenOn": "2019-03-26T21:07:53Z",
      "side": 1,
      "message": "I\u0027m honestly not sure exactly what this is doing...",
      "parentUuid": "1ebd3636_e25a3943",
      "revId": "d1e9cf0554b5dd826c17a9a4d9cfc76953f4c23c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7163b17_fcdf3d4a",
        "filename": "lifecycle/runtime/eap/lint/src/main/java/androidx/lifecycle/lint/LifecycleWhenChecks.kt",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 1098853
      },
      "writtenOn": "2019-03-26T21:20:58Z",
      "side": 1,
      "message": "It is here to avoid loops. I resolve called methods and visit their declarations, method can call itself, so then I\u0027d go in depth forever. To prevent that I have this \"visited\" set. \nIt is kinda worries me a bit, because it seems that lint check can be super expensive. Should I add hard limit on depth as well...",
      "parentUuid": "b2ea65a5_4acc476f",
      "revId": "d1e9cf0554b5dd826c17a9a4d9cfc76953f4c23c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "558de19d_91ad289a",
        "filename": "lifecycle/runtime/eap/lint/src/main/java/androidx/lifecycle/lint/LifecycleWhenChecks.kt",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 1004689
      },
      "writtenOn": "2019-03-26T21:25:12Z",
      "side": 1,
      "message": "Do you have a unit test for this recursive case? I\u0027m asking because the resolve call jumps out of UAST and into PSI, so when you calll toUelement (on line 252) you\u0027re creating a new UAST tree; I\u0027m not 100% certain that calling equals on those nodes will be true for two separate invocations to the same node; you\u0027d need to cache the UElement.psi() source nodes instead.\n\nIt sounds like what you really want is whole program analysis where you get the whole control flow or data flow graph. We do have some support for that (see the interprocedural thread checker) but it\u0027s pretty expensive and something we\u0027re still investigating. It\u0027s probably a good idea to limit your recursion here to just a few levels.",
      "parentUuid": "d7163b17_fcdf3d4a",
      "revId": "d1e9cf0554b5dd826c17a9a4d9cfc76953f4c23c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}