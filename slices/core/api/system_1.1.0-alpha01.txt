// Signature format: 2.0
package androidx.slice {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) class ArrayUtils {
    ctor private ArrayUtils();
    method public static <T> T[]! appendElement(Class<T>!, T[]!, T!);
    method public static <T> boolean contains(T[]!, T!);
    method public static <T> T[]! removeElement(Class<T>!, T[]!, T!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public interface Clock {
    method public long currentTimeMillis();
  }

  @RequiresApi(19) public final class Slice extends androidx.versionedparcelable.CustomVersionedParcelable implements androidx.versionedparcelable.VersionedParcelable {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) Slice(java.util.ArrayList<androidx.slice.SliceItem>!, String[]!, android.net.Uri!, androidx.slice.SliceSpec!);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public Slice();
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public Slice(android.os.Bundle!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public static void appendHints(StringBuilder!, String[]!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.slice.Slice? bindSlice(android.content.Context!, android.net.Uri, java.util.Set<androidx.slice.SliceSpec>!);
    method @RequiresApi(28) private static androidx.slice.Slice! callBindSlice(android.content.Context!, android.net.Uri!, java.util.Set<androidx.slice.SliceSpec>!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.slice.SliceSpec? getSpec();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public boolean hasHint(String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) static boolean isValidIcon(androidx.core.graphics.drawable.IconCompat!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public android.os.Bundle! toBundle();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public String! toString(String!);
    field private static final String HINTS = "hints";
    field private static final String ITEMS = "items";
    field static final String[]! NO_HINTS;
    field static final androidx.slice.SliceItem[]! NO_ITEMS;
    field private static final String SPEC_REVISION = "revision";
    field private static final String SPEC_TYPE = "type";
    field private static final String URI = "uri";
    field String[]! mHints;
    field androidx.slice.SliceItem[]! mItems;
    field androidx.slice.SliceSpec! mSpec;
    field String! mUri;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static class Slice.Builder {
    ctor public Slice.Builder(android.net.Uri);
    ctor public Slice.Builder(androidx.slice.Slice.Builder);
    method public androidx.slice.Slice.Builder! addAction(android.app.PendingIntent, androidx.slice.Slice, String?);
    method public androidx.slice.Slice.Builder! addAction(androidx.slice.SliceItem.ActionHandler, androidx.slice.Slice, String?);
    method public androidx.slice.Slice.Builder! addHints(java.lang.String...!);
    method public androidx.slice.Slice.Builder! addHints(java.util.List<java.lang.String>!);
    method public androidx.slice.Slice.Builder! addIcon(androidx.core.graphics.drawable.IconCompat!, String?, java.lang.String...!);
    method public androidx.slice.Slice.Builder! addIcon(androidx.core.graphics.drawable.IconCompat!, String?, java.util.List<java.lang.String>!);
    method public androidx.slice.Slice.Builder! addInt(int, String?, java.lang.String...!);
    method public androidx.slice.Slice.Builder! addInt(int, String?, java.util.List<java.lang.String>!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public androidx.slice.Slice.Builder! addItem(androidx.slice.SliceItem!);
    method public androidx.slice.Slice.Builder! addLong(long, String?, java.lang.String...!);
    method public androidx.slice.Slice.Builder! addLong(long, String?, java.util.List<java.lang.String>!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.slice.Slice.Builder! addRemoteInput(android.app.RemoteInput!, String?, java.util.List<java.lang.String>!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.slice.Slice.Builder! addRemoteInput(android.app.RemoteInput!, String?, java.lang.String...!);
    method public androidx.slice.Slice.Builder! addSubSlice(androidx.slice.Slice);
    method public androidx.slice.Slice.Builder! addSubSlice(androidx.slice.Slice, String!);
    method public androidx.slice.Slice.Builder! addText(CharSequence!, String?, java.lang.String...!);
    method public androidx.slice.Slice.Builder! addText(CharSequence!, String?, java.util.List<java.lang.String>!);
    method @Deprecated public androidx.slice.Slice.Builder! addTimestamp(long, String?, java.lang.String...!);
    method public androidx.slice.Slice.Builder! addTimestamp(long, String?, java.util.List<java.lang.String>!);
    method public androidx.slice.Slice! build();
    method private android.net.Uri! getChildUri();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.slice.Slice.Builder! setSpec(androidx.slice.SliceSpec!);
    field private int mChildId;
    field private java.util.ArrayList<java.lang.String>! mHints;
    field private java.util.ArrayList<androidx.slice.SliceItem>! mItems;
    field private androidx.slice.SliceSpec! mSpec;
    field private final android.net.Uri! mUri;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @StringDef({android.app.slice.Slice.HINT_TITLE, android.app.slice.Slice.HINT_LIST, android.app.slice.Slice.HINT_LIST_ITEM, android.app.slice.Slice.HINT_LARGE, android.app.slice.Slice.HINT_ACTIONS, android.app.slice.Slice.HINT_SELECTED, android.app.slice.Slice.HINT_HORIZONTAL, android.app.slice.Slice.HINT_NO_TINT, android.app.slice.Slice.HINT_PARTIAL, android.app.slice.Slice.HINT_SUMMARY, android.app.slice.Slice.HINT_SEE_MORE, android.app.slice.Slice.HINT_SHORTCUT, android.app.slice.Slice.HINT_KEYWORDS, android.app.slice.Slice.HINT_TTL, android.app.slice.Slice.HINT_LAST_UPDATED, android.app.slice.Slice.HINT_PERMISSION_REQUEST, android.app.slice.Slice.HINT_ERROR, androidx.slice.core.SliceHints.HINT_ACTIVITY, androidx.slice.core.SliceHints.HINT_CACHED, androidx.slice.core.SliceHints.HINT_SELECTION}) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface Slice.SliceHint {
  }

  @RequiresApi(28) public class SliceConvert {
    ctor private SliceConvert();
    method private static android.app.slice.SliceSpec! unwrap(androidx.slice.SliceSpec!);
    method static java.util.Set<android.app.slice.SliceSpec>! unwrap(java.util.Set<androidx.slice.SliceSpec>!);
    method private static androidx.slice.SliceSpec! wrap(android.app.slice.SliceSpec!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public static java.util.Set<androidx.slice.SliceSpec>! wrap(java.util.Set<android.app.slice.SliceSpec>!);
    field private static final String TAG = "SliceConvert";
  }

  @RequiresApi(19) public final class SliceItem extends androidx.versionedparcelable.CustomVersionedParcelable {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public SliceItem(Object!, String!, String!, String[]!);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public SliceItem(Object!, String!, String!, java.util.List<java.lang.String>!);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public SliceItem();
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public SliceItem(android.app.PendingIntent!, androidx.slice.Slice!, String!, String!, String[]!);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public SliceItem(androidx.slice.SliceItem.ActionHandler!, androidx.slice.Slice!, String!, String!, String[]!);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public SliceItem(android.os.Bundle!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public void addHint(String!);
    method private static boolean checkSpan(Object!);
    method private static boolean checkSpannedText(android.text.Spanned!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public boolean fireActionInternal(android.content.Context?, android.content.Intent?) throws android.app.PendingIntent.CanceledException;
    method private static Object! fixSpan(Object!);
    method private static void fixSpannableText(android.text.Spannable!);
    method @RequiresApi(20) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.app.RemoteInput! getRemoteInput();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public CharSequence! getSanitizedText();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public boolean hasAnyHints(java.lang.String...!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public boolean hasHints(String[]!);
    method private static String! layoutDirectionToString(int);
    method private static Object! readObj(String!, android.os.Bundle!);
    method private static CharSequence! sanitizeText(CharSequence!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public android.os.Bundle! toBundle();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public String! toString(String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public static String! typeToString(String!);
    method private void writeObj(android.os.Bundle!, Object!, String!);
    field private static final String FORMAT = "format";
    field private static final String HINTS = "hints";
    field private static final String OBJ = "obj";
    field private static final String OBJ_2 = "obj_2";
    field private static final String SUBTYPE = "subtype";
    field String! mFormat;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) protected String[]! mHints;
    field androidx.slice.SliceItemHolder! mHolder;
    field Object! mObj;
    field CharSequence! mSanitizedText;
    field String! mSubType;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface SliceItem.ActionHandler {
    method public void onAction(androidx.slice.SliceItem!, android.content.Context!, android.content.Intent!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @StringDef({android.app.slice.SliceItem.FORMAT_SLICE, android.app.slice.SliceItem.FORMAT_TEXT, android.app.slice.SliceItem.FORMAT_IMAGE, android.app.slice.SliceItem.FORMAT_ACTION, android.app.slice.SliceItem.FORMAT_INT, android.app.slice.SliceItem.FORMAT_LONG, android.app.slice.SliceItem.FORMAT_REMOTE_INPUT, android.app.slice.SliceItem.FORMAT_LONG}) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface SliceItem.SliceType {
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) public class SliceItemHolder implements androidx.versionedparcelable.VersionedParcelable {
    ctor SliceItemHolder(androidx.slice.SliceItemHolder.SliceItemPool!);
    ctor public SliceItemHolder(String!, Object!, boolean);
    method public Object! getObj(String!);
    method public void release();
    field Object! mCallback;
    field int mInt;
    field long mLong;
    field android.os.Parcelable! mParcelable;
    field private androidx.slice.SliceItemHolder.SliceItemPool! mPool;
    field String! mStr;
    field public androidx.versionedparcelable.VersionedParcelable! mVersionedParcelable;
    field public static androidx.slice.SliceItemHolder.HolderHandler! sHandler;
    field public static final Object! sSerializeLock;
  }

  public static interface SliceItemHolder.HolderHandler {
    method public void handle(androidx.slice.SliceItemHolder!, String!);
  }

  public static class SliceItemHolder.SliceItemPool {
    ctor public SliceItemHolder.SliceItemPool();
    method public androidx.slice.SliceItemHolder! get();
    method public void release(androidx.slice.SliceItemHolder!);
    field private final java.util.ArrayList<androidx.slice.SliceItemHolder>! mCached;
  }

  @RequiresApi(19) public abstract class SliceManager {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) SliceManager();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public abstract java.util.Set<androidx.slice.SliceSpec> getPinnedSpecs(android.net.Uri);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) class SliceManagerCompat extends androidx.slice.SliceManager {
    ctor SliceManagerCompat(android.content.Context!);
    method public java.util.Set<androidx.slice.SliceSpec> getPinnedSpecs(android.net.Uri);
    field private final android.content.Context! mContext;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(api=28) class SliceManagerWrapper extends androidx.slice.SliceManager {
    ctor SliceManagerWrapper(android.content.Context!);
    ctor SliceManagerWrapper(android.app.slice.SliceManager!);
    method private int getCurrentUserId();
    method public java.util.Set<androidx.slice.SliceSpec> getPinnedSpecs(android.net.Uri);
    method private android.net.Uri! maybeAddCurrentUserId(android.net.Uri!);
    field private final android.app.slice.SliceManager! mManager;
  }

  public abstract class SliceProvider extends android.content.ContentProvider implements androidx.core.app.CoreComponentFactory.CompatWrapped {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public static android.app.PendingIntent! createPermissionIntent(android.content.Context!, android.net.Uri!, String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public static androidx.slice.Slice! createPermissionSlice(android.content.Context!, android.net.Uri!, String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) public static androidx.slice.Clock! getClock();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public static java.util.Set<androidx.slice.SliceSpec>! getCurrentSpecs();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public static CharSequence! getPermissionString(android.content.Context!, String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) public void handleSlicePinned(android.net.Uri!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) public void handleSliceUnpinned(android.net.Uri!);
    method @VisibleForTesting @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) protected androidx.slice.compat.CompatPermissionManager! onCreatePermissionManager(String[]!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) public static void setClock(androidx.slice.Clock!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) public static void setSpecs(java.util.Set<androidx.slice.SliceSpec>!);
    field private static final boolean DEBUG = false;
    field private static final String TAG = "SliceProvider";
    field private final String[]! mAutoGrantPermissions;
    field private androidx.slice.compat.SliceProviderCompat! mCompat;
    field private java.util.List<android.net.Uri>! mPinnedSliceUris;
    field private static androidx.slice.Clock! sClock;
    field private static java.util.Set<androidx.slice.SliceSpec>! sSpecs;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public final class SliceSpec implements androidx.versionedparcelable.VersionedParcelable {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public SliceSpec();
    ctor public SliceSpec(String, int);
    method public boolean canRender(androidx.slice.SliceSpec);
    method public int getRevision();
    method public String! getType();
    field int mRevision;
    field String! mType;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public class SliceSpecs {
    ctor private SliceSpecs();
    field public static final androidx.slice.SliceSpec! BASIC;
    field public static final androidx.slice.SliceSpec! LIST;
    field public static final androidx.slice.SliceSpec! MESSAGING;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public class SystemClock implements androidx.slice.Clock {
    ctor public SystemClock();
    method public long currentTimeMillis();
  }

}

package androidx.slice.compat {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) public class CompatPermissionManager {
    ctor public CompatPermissionManager(android.content.Context!, String!, int, String[]!);
    method public int checkSlicePermission(android.net.Uri!, int, int);
    method private int checkSlicePermission(android.net.Uri!, String!);
    method private androidx.slice.compat.CompatPermissionManager.PermissionState! getPermissionState(String!, String!);
    method private android.content.SharedPreferences! getPrefs();
    method public void grantSlicePermission(android.net.Uri!, String!);
    method private void persist(androidx.slice.compat.CompatPermissionManager.PermissionState!);
    method public void revokeSlicePermission(android.net.Uri!, String!);
    field public static final String ALL_SUFFIX = "_all";
    field private static final String TAG = "CompatPermissionManager";
    field private final String[]! mAutoGrantPermissions;
    field private final android.content.Context! mContext;
    field private final int mMyUid;
    field private final String! mPrefsName;
  }

  public static class CompatPermissionManager.PermissionState {
    ctor CompatPermissionManager.PermissionState(java.util.Set<java.lang.String>!, String!, boolean);
    method boolean addPath(java.util.List<java.lang.String>!);
    method private String[]! decodeSegments(String!);
    method private String! encodeSegments(String[]!);
    method public String! getKey();
    method public boolean hasAccess(java.util.List<java.lang.String>!);
    method public boolean hasAllPermissions();
    method private boolean isPathPrefixMatch(String[]!, String[]!);
    method boolean removePath(java.util.List<java.lang.String>!);
    method public java.util.Set<java.lang.String>! toPersistable();
    field private final String! mKey;
    field private final androidx.collection.ArraySet<java.lang.String[]>! mPaths;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) public class CompatPinnedList {
    ctor public CompatPinnedList(android.content.Context!, String!);
    method public boolean addPin(android.net.Uri!, String!, java.util.Set<androidx.slice.SliceSpec>!);
    method private static androidx.slice.SliceSpec! findSpec(java.util.Set<androidx.slice.SliceSpec>!, String!);
    method @VisibleForTesting protected long getBootTime();
    method public java.util.List<android.net.Uri>! getPinnedSlices();
    method private java.util.Set<java.lang.String>! getPins(android.net.Uri!);
    method private android.content.SharedPreferences! getPrefs();
    method public androidx.collection.ArraySet<androidx.slice.SliceSpec>! getSpecs(android.net.Uri!);
    method private static androidx.collection.ArraySet<androidx.slice.SliceSpec>! mergeSpecs(androidx.collection.ArraySet<androidx.slice.SliceSpec>!, java.util.Set<androidx.slice.SliceSpec>!);
    method public boolean removePin(android.net.Uri!, String!);
    method private void setPins(android.net.Uri!, java.util.Set<java.lang.String>!);
    method private void setSpecs(android.net.Uri!, androidx.collection.ArraySet<androidx.slice.SliceSpec>!);
    field private static final long BOOT_THRESHOLD = 2000L; // 0x7d0L
    field private static final String LAST_BOOT = "last_boot";
    field private static final String PIN_PREFIX = "pinned_";
    field private static final String SPEC_NAME_PREFIX = "spec_names_";
    field private static final String SPEC_REV_PREFIX = "spec_revs_";
    field private final android.content.Context! mContext;
    field private final String! mPrefsName;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) public class SlicePermissionActivity extends android.app.Activity implements android.content.DialogInterface.OnClickListener android.content.DialogInterface.OnDismissListener {
    ctor public SlicePermissionActivity();
    method private CharSequence! loadSafeLabel(android.content.pm.PackageManager!, android.content.pm.ApplicationInfo!);
    field private static final float MAX_LABEL_SIZE_PX = 500.0f;
    field private static final String TAG = "SlicePermissionActivity";
    field private String! mCallingPkg;
    field private androidx.appcompat.app.AlertDialog! mDialog;
    field private String! mProviderPkg;
    field private android.net.Uri! mUri;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) @RequiresApi(19) public class SliceProviderCompat {
    ctor public SliceProviderCompat(androidx.slice.SliceProvider!, androidx.slice.compat.CompatPermissionManager!, android.content.Context!);
    method private static androidx.slice.compat.SliceProviderCompat.ProviderHolder! acquireClient(android.content.ContentResolver!, android.net.Uri!);
    method public static void addSpecs(android.os.Bundle!, java.util.Set<androidx.slice.SliceSpec>!);
    method public static androidx.slice.Slice! bindSlice(android.content.Context!, android.net.Uri!, java.util.Set<androidx.slice.SliceSpec>!);
    method public static androidx.slice.Slice! bindSlice(android.content.Context!, android.content.Intent!, java.util.Set<androidx.slice.SliceSpec>!);
    method public android.os.Bundle! call(String!, String!, android.os.Bundle!);
    method public static int checkSlicePermission(android.content.Context!, String!, android.net.Uri!, int, int);
    method public String! getCallingPackage();
    method private android.content.Context! getContext();
    method public static java.util.List<android.net.Uri>! getPinnedSlices(android.content.Context!);
    method public static java.util.Set<androidx.slice.SliceSpec>! getPinnedSpecs(android.content.Context!, android.net.Uri!);
    method public static java.util.Collection<android.net.Uri> getSliceDescendants(android.content.Context!, android.net.Uri);
    method public static java.util.Set<androidx.slice.SliceSpec>! getSpecs(android.os.Bundle!);
    method public static void grantSlicePermission(android.content.Context!, String!, String!, android.net.Uri!);
    method private androidx.slice.Slice! handleBindSlice(android.net.Uri!, java.util.Set<androidx.slice.SliceSpec>!, String!);
    method private java.util.Collection<android.net.Uri>! handleGetDescendants(android.net.Uri!);
    method private void handleSlicePinned(android.net.Uri!);
    method private void handleSliceUnpinned(android.net.Uri!);
    method public static android.net.Uri! mapIntentToUri(android.content.Context!, android.content.Intent!);
    method private androidx.slice.Slice! onBindSliceStrict(android.net.Uri!, java.util.Set<androidx.slice.SliceSpec>!);
    method private static androidx.slice.Slice! parseSlice(android.content.Context!, android.os.Bundle!);
    method public static void pinSlice(android.content.Context!, android.net.Uri!, java.util.Set<androidx.slice.SliceSpec>!);
    method public static void revokeSlicePermission(android.content.Context!, String!, String!, android.net.Uri!);
    method public static void unpinSlice(android.content.Context!, android.net.Uri!, java.util.Set<androidx.slice.SliceSpec>!);
    field private static final String ALL_FILES = "slice_data_all_slice_files";
    field public static final String ARG_SUPPORTS_VERSIONED_PARCELABLE = "supports_versioned_parcelable";
    field private static final String DATA_PREFIX = "slice_data_";
    field public static final String EXTRA_BIND_URI = "slice_uri";
    field public static final String EXTRA_INTENT = "slice_intent";
    field public static final String EXTRA_PID = "pid";
    field public static final String EXTRA_PKG = "pkg";
    field public static final String EXTRA_PROVIDER_PKG = "provider_pkg";
    field public static final String EXTRA_RESULT = "result";
    field public static final String EXTRA_SLICE = "slice";
    field public static final String EXTRA_SLICE_DESCENDANTS = "slice_descendants";
    field public static final String EXTRA_SUPPORTED_SPECS = "specs";
    field public static final String EXTRA_SUPPORTED_SPECS_REVS = "revs";
    field public static final String EXTRA_UID = "uid";
    field public static final String METHOD_CHECK_PERMISSION = "check_perms";
    field public static final String METHOD_GET_DESCENDANTS = "get_descendants";
    field public static final String METHOD_GET_PINNED_SPECS = "get_specs";
    field public static final String METHOD_GRANT_PERMISSION = "grant_perms";
    field public static final String METHOD_MAP_INTENT = "map_slice";
    field public static final String METHOD_MAP_ONLY_INTENT = "map_only";
    field public static final String METHOD_PIN = "pin_slice";
    field public static final String METHOD_REVOKE_PERMISSION = "revoke_perms";
    field public static final String METHOD_SLICE = "bind_slice";
    field public static final String METHOD_UNPIN = "unpin_slice";
    field public static final String PERMS_PREFIX = "slice_perms_";
    field private static final long SLICE_BIND_ANR = 2000L; // 0x7d0L
    field private static final String TAG = "SliceProviderCompat";
    field private final Runnable! mAnr;
    field String! mCallback;
    field private final android.content.Context! mContext;
    field private final android.os.Handler! mHandler;
    field private androidx.slice.compat.CompatPermissionManager! mPermissionManager;
    field private androidx.slice.compat.CompatPinnedList! mPinnedList;
    field private final androidx.slice.SliceProvider! mProvider;
  }

  private static class SliceProviderCompat.ProviderHolder implements java.lang.AutoCloseable {
    ctor SliceProviderCompat.ProviderHolder(android.content.ContentProviderClient!);
    field final android.content.ContentProviderClient! mProvider;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public class SliceProviderWrapperContainer {
    ctor private SliceProviderWrapperContainer();
  }

  @RequiresApi(28) public static class SliceProviderWrapperContainer.SliceProviderWrapper extends android.app.slice.SliceProvider {
    ctor public SliceProviderWrapperContainer.SliceProviderWrapper(androidx.slice.SliceProvider!, String[]!);
    method private void checkPermissions(android.net.Uri!);
    field private static final String EXTRA_INTENT = "slice_intent";
    field private static final String EXTRA_URI = "slice_uri";
    field private static final String METHOD_BIND = "bind_slice";
    field private static final String METHOD_MAP = "map_slice";
    field private static final String TAG = "SliceProviderWrapper";
    field private String[]! mAutoGrantPermissions;
    field private android.app.slice.SliceManager! mSliceManager;
    field private androidx.slice.SliceProvider! mSliceProvider;
  }

}

package androidx.slice.core {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public class SliceActionImpl implements androidx.slice.core.SliceAction {
    ctor public SliceActionImpl(android.app.PendingIntent, androidx.core.graphics.drawable.IconCompat, CharSequence);
    ctor public SliceActionImpl(android.app.PendingIntent, androidx.core.graphics.drawable.IconCompat, int, CharSequence);
    ctor public SliceActionImpl(android.app.PendingIntent, androidx.core.graphics.drawable.IconCompat, CharSequence, boolean);
    ctor public SliceActionImpl(android.app.PendingIntent, CharSequence, boolean);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public SliceActionImpl(androidx.slice.SliceItem!);
    method public androidx.slice.Slice buildPrimaryActionSlice(androidx.slice.Slice.Builder);
    method public androidx.slice.Slice buildSlice(androidx.slice.Slice.Builder);
    method private androidx.slice.Slice.Builder! buildSliceContent(androidx.slice.Slice.Builder);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.slice.SliceItem! getActionItem();
    method public androidx.slice.SliceItem? getSliceItem();
    method public String? getSubtype();
    method public void setActivity(boolean);
    field private android.app.PendingIntent! mAction;
    field private androidx.slice.SliceItem! mActionItem;
    field private CharSequence! mContentDescription;
    field private androidx.core.graphics.drawable.IconCompat! mIcon;
    field private int mImageMode;
    field private boolean mIsActivity;
    field private boolean mIsChecked;
    field private boolean mIsToggle;
    field private int mPriority;
    field private androidx.slice.SliceItem! mSliceItem;
    field private CharSequence! mTitle;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public class SliceHints {
    ctor private SliceHints();
    field public static final String HINT_ACTIVITY = "activity";
    field public static final String HINT_CACHED = "cached";
    field public static final String HINT_SELECTION = "selection";
    field public static final int ICON_IMAGE = 0; // 0x0
    field public static final long INFINITY = -1L; // 0xffffffffffffffffL
    field public static final int LARGE_IMAGE = 2; // 0x2
    field public static final String SLICE_METADATA_KEY = "android.metadata.SLICE_URI";
    field public static final int SMALL_IMAGE = 1; // 0x1
    field public static final String SUBTYPE_MILLIS = "millis";
    field public static final String SUBTYPE_MIN = "min";
    field public static final String SUBTYPE_SELECTION_OPTION_KEY = "selection_option_key";
    field public static final int UNKNOWN_IMAGE = 3; // 0x3
  }

  @IntDef({androidx.slice.core.SliceHints.LARGE_IMAGE, androidx.slice.core.SliceHints.SMALL_IMAGE, androidx.slice.core.SliceHints.ICON_IMAGE, androidx.slice.core.SliceHints.UNKNOWN_IMAGE}) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface SliceHints.ImageMode {
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(19) public class SliceQuery {
    ctor private SliceQuery();
    method static boolean checkFormat(androidx.slice.SliceItem!, String!);
    method static boolean checkSubtype(androidx.slice.SliceItem!, String!);
    method private static <T> java.util.List<T>! collect(java.util.Iterator<T>!);
    method private static boolean contains(androidx.slice.SliceItem!, androidx.slice.SliceItem!);
    method private static <T> java.util.Iterator<T>! filter(java.util.Iterator<T>!, androidx.slice.core.SliceQuery.Filter<T>!);
    method public static androidx.slice.SliceItem! find(androidx.slice.Slice!, String!, String!, String!);
    method public static androidx.slice.SliceItem! find(androidx.slice.Slice!, String!);
    method public static androidx.slice.SliceItem! find(androidx.slice.SliceItem!, String!);
    method public static androidx.slice.SliceItem! find(androidx.slice.SliceItem!, String!, String!, String!);
    method public static androidx.slice.SliceItem! find(androidx.slice.Slice!, String!, String[]!, String[]!);
    method public static androidx.slice.SliceItem! find(androidx.slice.SliceItem!, String!, String[]!, String[]!);
    method public static java.util.List<androidx.slice.SliceItem>! findAll(androidx.slice.SliceItem!, String!);
    method public static java.util.List<androidx.slice.SliceItem>! findAll(androidx.slice.Slice!, String!, String!, String!);
    method public static java.util.List<androidx.slice.SliceItem>! findAll(androidx.slice.SliceItem!, String!, String!, String!);
    method public static java.util.List<androidx.slice.SliceItem>! findAll(androidx.slice.Slice!, String!, String[]!, String[]!);
    method public static java.util.List<androidx.slice.SliceItem>! findAll(androidx.slice.SliceItem!, String!, String[]!, String[]!);
    method private static <T> T! findFirst(java.util.Iterator<T>!, T!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.slice.SliceItem! findItem(androidx.slice.Slice!, android.net.Uri!);
    method public static androidx.slice.SliceItem! findNotContaining(androidx.slice.SliceItem!, java.util.List<androidx.slice.SliceItem>!);
    method public static androidx.slice.SliceItem! findSubtype(androidx.slice.Slice!, String!, String!);
    method public static androidx.slice.SliceItem! findSubtype(androidx.slice.SliceItem!, String!, String!);
    method public static androidx.slice.SliceItem! findTopLevelItem(androidx.slice.Slice!, String!, String!, String[]!, String[]!);
    method private static java.util.Iterator<androidx.slice.SliceItem>! getSliceItemStream(java.util.ArrayList<androidx.slice.SliceItem>!);
    method public static boolean hasAnyHints(androidx.slice.SliceItem!, java.lang.String...!);
    method public static boolean hasHints(androidx.slice.SliceItem!, java.lang.String...!);
    method public static boolean hasHints(androidx.slice.Slice!, java.lang.String...!);
    method public static java.util.Iterator<androidx.slice.SliceItem>! stream(androidx.slice.SliceItem!);
    method public static java.util.Iterator<androidx.slice.SliceItem>! stream(androidx.slice.Slice!);
  }

  private static interface SliceQuery.Filter<T> {
    method public boolean filter(T!);
  }

}

