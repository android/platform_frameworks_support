{
  "comments": [
    {
      "key": {
        "uuid": "17d0c0bc_77344fa1",
        "filename": "ui/framework/src/main/java/androidx/ui/core/Draw.kt",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1361834
      },
      "writtenOn": "2019-05-30T11:13:33Z",
      "side": 1,
      "message": "will be nice to provide more info about the paint, explain the motivation why you should use it, explain in what state it will be(I hope it will be reset to the defaults, see my second comment)",
      "range": {
        "startLine": 25,
        "startChar": 34,
        "endLine": 25,
        "endChar": 41
      },
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "753ac79c_51d8101f",
        "filename": "ui/platform/src/main/java/androidx/ui/core/ComponentNodes.kt",
        "patchSetId": 2
      },
      "lineNbr": 348,
      "author": {
        "id": 1493285
      },
      "writtenOn": "2019-05-29T21:42:00Z",
      "side": 1,
      "message": "How often will we have DrawNodes that don\u0027t need a Paint instance? From this CL, it looks like maybe not very often? If so, this seems like a reasonable thing to do (though I\u0027m a little bit bummed about adding yet-another parameter to `onPaint`).",
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9abe3e6_47571bf2",
        "filename": "ui/platform/src/main/java/androidx/ui/core/ComponentNodes.kt",
        "patchSetId": 2
      },
      "lineNbr": 348,
      "author": {
        "id": 1345596
      },
      "writtenOn": "2019-05-29T21:59:10Z",
      "side": 1,
      "message": "Yes I am wondering if we can get by without it. Depending on the scope of the usage, a single paint could be accessed across multiple DrawNode instances similar to how dependencies of other composables would still be accessible. Rather than assuming each DrawNode would have it\u0027s own paint, maybe we could get by with a specialized paint memoization effect instead for now and see if that satisfies our use case?",
      "parentUuid": "753ac79c_51d8101f",
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a9282c6_766a3cef",
        "filename": "ui/platform/src/main/java/androidx/ui/core/ComponentNodes.kt",
        "patchSetId": 2
      },
      "lineNbr": 348,
      "author": {
        "id": 1416041
      },
      "writtenOn": "2019-05-29T22:54:23Z",
      "side": 1,
      "message": "I can imagine usecases when you want only to clip canvas and drawChildren() and you don\u0027t need paint, like in Scroller.kt above. \n\nFor this usecases we will create unnecessary Paint, that\u0027s a problem.\n\nRegarding effect, I considered this, but I\u0027m not sure if it will be discoverable enough for users. I can imagine situations where people use Draw node and just don\u0027t know about +paint effect and create their own every recomposition cycle.\n\nWe can have two Draw overloads, one with Paint and one without. Not sure it then it will be discoverable enough... What\u0027s your thought on this?",
      "parentUuid": "d9abe3e6_47571bf2",
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ee56220_984a2428",
        "filename": "ui/platform/src/main/java/androidx/ui/core/ComponentNodes.kt",
        "patchSetId": 2
      },
      "lineNbr": 348,
      "author": {
        "id": 1060493
      },
      "writtenOn": "2019-05-29T23:03:58Z",
      "side": 1,
      "message": "I have seen very few examples of the Draw used without a Paint and very few examples of reusing a Paint between different Draws. I have seen many examples of Paint() instantiated on every draw call.\n\nI don\u0027t think it is worth having multiple overloads until we see it being used regularly without the Paint parameter. In other words, I think it is better to optimize the API later when we know more about the real uses.",
      "parentUuid": "5a9282c6_766a3cef",
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "832c7b93_de8dd31c",
        "filename": "ui/platform/src/main/java/androidx/ui/core/ComponentNodes.kt",
        "patchSetId": 2
      },
      "lineNbr": 348,
      "author": {
        "id": 1345596
      },
      "writtenOn": "2019-05-29T23:07:31Z",
      "side": 1,
      "message": "We should attempt to discourage allocations of a Paint within a DrawNode composable. Maybe we can make the Paint() constructor internal and the only way to obtain a paint is to use a memoized effect? This would enforce re-usage across composition without the worry of accidentally allocating a paint within a DrawNode. There could be usages of a composable function that draws some decorations around child widgets and uses several DrawNode instances but can re-use the same paint in this case.",
      "parentUuid": "3ee56220_984a2428",
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf9b39e4_15950485",
        "filename": "ui/platform/src/main/java/androidx/ui/core/ComponentNodes.kt",
        "patchSetId": 2
      },
      "lineNbr": 348,
      "author": {
        "id": 1416041
      },
      "writtenOn": "2019-05-29T23:37:07Z",
      "side": 1,
      "message": "\u003e There could be usages of a composable function that draws some decorations around child widgets and uses several DrawNode instances but can re-use the same paint in this case.\n\nProbably it\u0027s a speculation, but in order to pass Paint down, you have to know that you have DrawNodes down the hierarchy, it usually means that you own them, then you can even avoid multiply DrawNodes and draw everything in one DrawNode and introduce just functions instead of DrawNodes. Am I wrong?\n\n\nThe idea with internal Paint() in interesting, we can consider this. I\u0027m afraid that then you won\u0027t be able to create paint nowhere else besides composition scope, so we will need to introduce some other factory methods in order to work around it. I don\u0027t know right now, how we can avoid just several +paint() invocations, which will create several Paint objects. It might be not a problem, but potentially people can use it this way.\n\nPlease note that I\u0027m not saying this is a good and/or final API, but I think it solves our problems and encourage better design (for example, as it\u0027s already provided, you don\u0027t even think about creating the new one).",
      "parentUuid": "832c7b93_de8dd31c",
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80b565aa_d1712225",
        "filename": "ui/platform/src/main/java/androidx/ui/core/ComponentNodes.kt",
        "patchSetId": 2
      },
      "lineNbr": 348,
      "author": {
        "id": 1361834
      },
      "writtenOn": "2019-05-30T11:13:33Z",
      "side": 1,
      "message": "I am also a bit nervous about reusing the old paint everytime without \"reseting\" it. DrawNode can be reused but the new onPaint will do something new.\nFor example the old lambda was changing paint.style to PaintingStyle.stroke. And the new lambda is just assuming the paint has default values and will not specify PaintingStyle.fill. Something unexpected will be drawn then.\nIt can be solved if in Paint we will add a method paint.reset(), the same like in Path (the framework Paint class already have this method) and will be calling it after every draw.\n\nIt will also help if inside one Draw we would want to draw two independent things: you configure paint, you draw, you call reset, you configure it for the second usage and draw again",
      "parentUuid": "bf9b39e4_15950485",
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7e42335_92dd0415",
        "filename": "ui/platform/src/main/java/androidx/ui/core/ComponentNodes.kt",
        "patchSetId": 2
      },
      "lineNbr": 348,
      "author": {
        "id": 1493285
      },
      "writtenOn": "2019-05-30T16:59:05Z",
      "side": 1,
      "message": "i think it would be very difficult right now to have the paint end up in a state that you\u0027re not aware of because of node reuse. DrawNodes won\u0027t be reused across tags/source locations, so it should be 1 to 1 with the onPaint lambdas, which probably have an expectation of reuse across executions but just for that lambda?\n\nWas talking with Chuck about this yesterday, and he had an interesting idea:\n\nWe could make Paint immutable, and then pool the construction of the underlying instances based on a hash of their properties.\n\nI\u0027m good with this PR as is, as I think it improves the current state by quite a bit, but perhaps this is something we want to consider as well as a more satisfiable long-term solution. It feels weird to me to have Paint and DrawNode be 1 to 1.",
      "parentUuid": "80b565aa_d1712225",
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a45b82a0_0eb1caf8",
        "filename": "ui/platform/src/main/java/androidx/ui/core/ComponentNodes.kt",
        "patchSetId": 2
      },
      "lineNbr": 348,
      "author": {
        "id": 1361834
      },
      "writtenOn": "2019-05-30T19:17:44Z",
      "side": 1,
      "message": "The issue I am referring to can be reproduced easily. Consider \nDraw { canvas, paint, parentSize -\u003e\n  paint.color \u003d Color.Red\n  canvas.drawRect(parentSize.toRect(), paint)\n  paint.color \u003d Color.Blue\n  paint.style \u003d PaintingStyle.stroke\n  canvas.drawRect(parentSize.toRect(), paint)\n}\nThis will be drawn correctly for the first time but when reused style will not be reset to default PaintingStyle.fill so no filled rect drawn. It feels too fragile to ask developers to always remember this and truly understand what is going on. especially there is a possibility that this would never be recomposed during the testing of the widget so the issue would be discovered only at some point later.\nThe same with some conditional logic\nDraw { canvas, paint, parentSize -\u003e\n  if (someBoolean) {\n    paint.style \u003d PaintingStyle.stroke\n  }\n  canvas.drawRect(parentSize.toRect(), paint)\n}",
      "parentUuid": "e7e42335_92dd0415",
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a69ede57_02bd3d19",
        "filename": "ui/platform/src/main/java/androidx/ui/core/ComponentNodes.kt",
        "patchSetId": 2
      },
      "lineNbr": 348,
      "author": {
        "id": 1493285
      },
      "writtenOn": "2019-05-30T19:54:15Z",
      "side": 1,
      "message": "yeah, sorry - i wasn\u0027t clear. this is definitely an issue in this case, but seemed like a place where it\u0027s a fairly reasonable contract to follow. if this type of thing was happening across nodes, it would be a nightmare though.",
      "parentUuid": "a45b82a0_0eb1caf8",
      "revId": "b5df8473eaa5903e39bb2ca75221c4c9259bedcc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}