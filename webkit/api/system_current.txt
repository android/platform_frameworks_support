// Signature format: 2.0
package androidx.webkit {

  public abstract class SafeBrowsingResponseCompat {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public SafeBrowsingResponseCompat();
  }

  public abstract class ServiceWorkerControllerCompat {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public ServiceWorkerControllerCompat();
  }

  private static class ServiceWorkerControllerCompat.LAZY_HOLDER {
    ctor private ServiceWorkerControllerCompat.LAZY_HOLDER();
    field static final androidx.webkit.ServiceWorkerControllerCompat! INSTANCE;
  }

  public abstract class ServiceWorkerWebSettingsCompat {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public ServiceWorkerWebSettingsCompat();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @IntDef({android.webkit.WebSettings.LOAD_DEFAULT, android.webkit.WebSettings.LOAD_CACHE_ELSE_NETWORK, android.webkit.WebSettings.LOAD_NO_CACHE, android.webkit.WebSettings.LOAD_CACHE_ONLY}) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface ServiceWorkerWebSettingsCompat.CacheMode {
  }

  public class WebMessageCompat {
    field private String! mData;
    field private androidx.webkit.WebMessagePortCompat[]! mPorts;
  }

  public abstract class WebMessagePortCompat {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public WebMessagePortCompat();
    method @RequiresApi(23) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public abstract android.webkit.WebMessagePort! getFrameworkPort();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public abstract java.lang.reflect.InvocationHandler! getInvocationHandler();
  }

  public abstract class WebResourceErrorCompat {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public WebResourceErrorCompat();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @IntDef({android.webkit.WebViewClient.ERROR_UNKNOWN, android.webkit.WebViewClient.ERROR_HOST_LOOKUP, android.webkit.WebViewClient.ERROR_UNSUPPORTED_AUTH_SCHEME, android.webkit.WebViewClient.ERROR_AUTHENTICATION, android.webkit.WebViewClient.ERROR_PROXY_AUTHENTICATION, android.webkit.WebViewClient.ERROR_CONNECT, android.webkit.WebViewClient.ERROR_IO, android.webkit.WebViewClient.ERROR_TIMEOUT, android.webkit.WebViewClient.ERROR_REDIRECT_LOOP, android.webkit.WebViewClient.ERROR_UNSUPPORTED_SCHEME, android.webkit.WebViewClient.ERROR_FAILED_SSL_HANDSHAKE, android.webkit.WebViewClient.ERROR_BAD_URL, android.webkit.WebViewClient.ERROR_FILE, android.webkit.WebViewClient.ERROR_FILE_NOT_FOUND, android.webkit.WebViewClient.ERROR_TOO_MANY_REQUESTS, android.webkit.WebViewClient.ERROR_UNSAFE_RESOURCE}) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface WebResourceErrorCompat.NetErrorCode {
  }

  public class WebResourceRequestCompat {
    ctor private WebResourceRequestCompat();
    method private static androidx.webkit.internal.WebResourceRequestAdapter! getAdapter(android.webkit.WebResourceRequest!);
  }

  public class WebSettingsCompat {
    ctor private WebSettingsCompat();
    method private static androidx.webkit.internal.WebSettingsAdapter! getAdapter(android.webkit.WebSettings!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @IntDef(flag=true, value={android.webkit.WebSettings.MENU_ITEM_NONE, android.webkit.WebSettings.MENU_ITEM_SHARE, android.webkit.WebSettings.MENU_ITEM_WEB_SEARCH, android.webkit.WebSettings.MENU_ITEM_PROCESS_TEXT}) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.METHOD}) public static @interface WebSettingsCompat.MenuItemFlags {
  }

  public class WebViewClientCompat extends android.webkit.WebViewClient implements org.chromium.support_lib_boundary.WebViewClientBoundaryInterface {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final String[]! getSupportedFeatures();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RequiresApi(21) public final void onReceivedError(android.webkit.WebView, android.webkit.WebResourceRequest, java.lang.reflect.InvocationHandler);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final void onSafeBrowsingHit(android.webkit.WebView, android.webkit.WebResourceRequest, int, java.lang.reflect.InvocationHandler);
    field private static final String[]! sSupportedFeatures;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @IntDef({android.webkit.WebViewClient.SAFE_BROWSING_THREAT_UNKNOWN, android.webkit.WebViewClient.SAFE_BROWSING_THREAT_MALWARE, android.webkit.WebViewClient.SAFE_BROWSING_THREAT_PHISHING, android.webkit.WebViewClient.SAFE_BROWSING_THREAT_UNWANTED_SOFTWARE}) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface WebViewClientCompat.SafeBrowsingThreat {
  }

  public class WebViewCompat {
    ctor private WebViewCompat();
    method private static void checkThread(android.webkit.WebView!);
    method private static org.chromium.support_lib_boundary.WebViewProviderBoundaryInterface! createProvider(android.webkit.WebView!);
    method private static androidx.webkit.internal.WebViewProviderFactory! getFactory();
    method private static android.content.pm.PackageInfo! getLoadedWebViewPackageInfo() throws java.lang.ClassNotFoundException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException, java.lang.NoSuchMethodException;
    method private static android.content.pm.PackageInfo! getNotYetLoadedWebViewPackageInfo(android.content.Context!);
    method private static androidx.webkit.internal.WebViewProviderAdapter! getProvider(android.webkit.WebView!);
    field private static final android.net.Uri! EMPTY_URI;
    field private static final android.net.Uri! WILDCARD_URI;
  }

  public class WebViewFeature {
    ctor private WebViewFeature();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @StringDef({androidx.webkit.WebViewFeature.VISUAL_STATE_CALLBACK, androidx.webkit.WebViewFeature.OFF_SCREEN_PRERASTER, androidx.webkit.WebViewFeature.SAFE_BROWSING_ENABLE, androidx.webkit.WebViewFeature.DISABLED_ACTION_MODE_MENU_ITEMS, androidx.webkit.WebViewFeature.START_SAFE_BROWSING, androidx.webkit.WebViewFeature.SAFE_BROWSING_WHITELIST, androidx.webkit.WebViewFeature.SAFE_BROWSING_PRIVACY_POLICY_URL, androidx.webkit.WebViewFeature.SERVICE_WORKER_BASIC_USAGE, androidx.webkit.WebViewFeature.SERVICE_WORKER_CACHE_MODE, androidx.webkit.WebViewFeature.SERVICE_WORKER_CONTENT_ACCESS, androidx.webkit.WebViewFeature.SERVICE_WORKER_FILE_ACCESS, androidx.webkit.WebViewFeature.SERVICE_WORKER_BLOCK_NETWORK_LOADS, androidx.webkit.WebViewFeature.SERVICE_WORKER_SHOULD_INTERCEPT_REQUEST, androidx.webkit.WebViewFeature.RECEIVE_WEB_RESOURCE_ERROR, androidx.webkit.WebViewFeature.RECEIVE_HTTP_ERROR, androidx.webkit.WebViewFeature.SHOULD_OVERRIDE_WITH_REDIRECTS, androidx.webkit.WebViewFeature.SAFE_BROWSING_HIT, androidx.webkit.WebViewFeature.WEB_RESOURCE_REQUEST_IS_REDIRECT, androidx.webkit.WebViewFeature.WEB_RESOURCE_ERROR_GET_DESCRIPTION, androidx.webkit.WebViewFeature.WEB_RESOURCE_ERROR_GET_CODE, androidx.webkit.WebViewFeature.SAFE_BROWSING_RESPONSE_BACK_TO_SAFETY, androidx.webkit.WebViewFeature.SAFE_BROWSING_RESPONSE_PROCEED, androidx.webkit.WebViewFeature.SAFE_BROWSING_RESPONSE_SHOW_INTERSTITIAL, androidx.webkit.WebViewFeature.WEB_MESSAGE_PORT_POST_MESSAGE, androidx.webkit.WebViewFeature.WEB_MESSAGE_PORT_CLOSE, androidx.webkit.WebViewFeature.WEB_MESSAGE_PORT_SET_MESSAGE_CALLBACK, androidx.webkit.WebViewFeature.CREATE_WEB_MESSAGE_CHANNEL, androidx.webkit.WebViewFeature.POST_WEB_MESSAGE, androidx.webkit.WebViewFeature.WEB_MESSAGE_CALLBACK_ON_MESSAGE, androidx.webkit.WebViewFeature.GET_WEB_VIEW_CLIENT, androidx.webkit.WebViewFeature.GET_WEB_CHROME_CLIENT, androidx.webkit.WebViewFeature.GET_WEB_VIEW_RENDERER, androidx.webkit.WebViewFeature.WEB_VIEW_RENDERER_TERMINATE}) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.METHOD}) public static @interface WebViewFeature.WebViewSupportFeature {
  }

  public abstract class WebViewRenderer {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public WebViewRenderer();
  }

}

package @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) androidx.webkit.internal {

  @RequiresApi(android.os.Build.VERSION_CODES.N) public class FrameworkServiceWorkerClient extends android.webkit.ServiceWorkerClient {
    ctor public FrameworkServiceWorkerClient(androidx.webkit.ServiceWorkerClientCompat!);
    field private final androidx.webkit.ServiceWorkerClientCompat! mImpl;
  }

  public class IncompatibleApkWebViewProviderFactory implements androidx.webkit.internal.WebViewProviderFactory {
    ctor public IncompatibleApkWebViewProviderFactory();
    method public org.chromium.support_lib_boundary.WebViewProviderBoundaryInterface! createWebView(android.webkit.WebView!);
    method public org.chromium.support_lib_boundary.ServiceWorkerControllerBoundaryInterface! getServiceWorkerController();
    method public org.chromium.support_lib_boundary.StaticsBoundaryInterface! getStatics();
    method public String[]! getWebViewFeatures();
    method public org.chromium.support_lib_boundary.WebkitToCompatConverterBoundaryInterface! getWebkitToCompatConverter();
    field private static final String[]! EMPTY_STRING_ARRAY;
    field private static final String UNSUPPORTED_EXCEPTION_EXPLANATION = "This should never happen, if this method was called it means we\'re trying to reach into WebView APK code on an incompatible device. This most likely means the current method is being called too early, or is being called on start-up rather than lazily";
  }

  public class SafeBrowsingResponseImpl extends androidx.webkit.SafeBrowsingResponseCompat {
    ctor public SafeBrowsingResponseImpl(java.lang.reflect.InvocationHandler);
    ctor public SafeBrowsingResponseImpl(android.webkit.SafeBrowsingResponse);
    method private org.chromium.support_lib_boundary.SafeBrowsingResponseBoundaryInterface! getBoundaryInterface();
    method @RequiresApi(27) private android.webkit.SafeBrowsingResponse! getFrameworksImpl();
    field private org.chromium.support_lib_boundary.SafeBrowsingResponseBoundaryInterface! mBoundaryInterface;
    field private android.webkit.SafeBrowsingResponse! mFrameworksImpl;
  }

  public class ServiceWorkerClientAdapter implements org.chromium.support_lib_boundary.ServiceWorkerClientBoundaryInterface {
    ctor public ServiceWorkerClientAdapter(androidx.webkit.ServiceWorkerClientCompat!);
    method public String[]! getSupportedFeatures();
    method public android.webkit.WebResourceResponse! shouldInterceptRequest(android.webkit.WebResourceRequest!);
    field private final androidx.webkit.ServiceWorkerClientCompat! mClient;
  }

  public class ServiceWorkerControllerImpl extends androidx.webkit.ServiceWorkerControllerCompat {
    ctor public ServiceWorkerControllerImpl();
    method private org.chromium.support_lib_boundary.ServiceWorkerControllerBoundaryInterface! getBoundaryInterface();
    method @RequiresApi(24) private android.webkit.ServiceWorkerController! getFrameworksImpl();
    field private org.chromium.support_lib_boundary.ServiceWorkerControllerBoundaryInterface! mBoundaryInterface;
    field private android.webkit.ServiceWorkerController! mFrameworksImpl;
    field private final androidx.webkit.ServiceWorkerWebSettingsCompat! mWebSettings;
  }

  public class ServiceWorkerWebSettingsImpl extends androidx.webkit.ServiceWorkerWebSettingsCompat {
    ctor public ServiceWorkerWebSettingsImpl(android.webkit.ServiceWorkerWebSettings);
    ctor public ServiceWorkerWebSettingsImpl(java.lang.reflect.InvocationHandler);
    method private org.chromium.support_lib_boundary.ServiceWorkerWebSettingsBoundaryInterface! getBoundaryInterface();
    method @RequiresApi(24) private android.webkit.ServiceWorkerWebSettings! getFrameworksImpl();
    field private org.chromium.support_lib_boundary.ServiceWorkerWebSettingsBoundaryInterface! mBoundaryInterface;
    field private android.webkit.ServiceWorkerWebSettings! mFrameworksImpl;
  }

  public class VisualStateCallbackAdapter implements org.chromium.support_lib_boundary.VisualStateCallbackBoundaryInterface {
    ctor public VisualStateCallbackAdapter(androidx.webkit.WebViewCompat.VisualStateCallback!);
    method public void onComplete(long);
    field private androidx.webkit.WebViewCompat.VisualStateCallback! mVisualStateCallback;
  }

  public class WebMessageAdapter implements org.chromium.support_lib_boundary.WebMessageBoundaryInterface {
    ctor WebMessageAdapter(androidx.webkit.WebMessageCompat!);
    method public String! getData();
    method public java.lang.reflect.InvocationHandler[]! getPorts();
    method public String[]! getSupportedFeatures();
    method private static androidx.webkit.WebMessagePortCompat[]! toWebMessagePortCompats(java.lang.reflect.InvocationHandler[]!);
    method public static androidx.webkit.WebMessageCompat! webMessageCompatFromBoundaryInterface(org.chromium.support_lib_boundary.WebMessageBoundaryInterface!);
    field private androidx.webkit.WebMessageCompat! mWebMessageCompat;
  }

  public class WebMessageCallbackAdapter implements org.chromium.support_lib_boundary.WebMessageCallbackBoundaryInterface {
    ctor WebMessageCallbackAdapter(androidx.webkit.WebMessagePortCompat.WebMessageCallbackCompat!);
    method public String[]! getSupportedFeatures();
    method public void onMessage(java.lang.reflect.InvocationHandler!, java.lang.reflect.InvocationHandler!);
    field androidx.webkit.WebMessagePortCompat.WebMessageCallbackCompat! mImpl;
  }

  public class WebMessagePortImpl extends androidx.webkit.WebMessagePortCompat {
    ctor public WebMessagePortImpl(android.webkit.WebMessagePort!);
    ctor public WebMessagePortImpl(java.lang.reflect.InvocationHandler!);
    method @RequiresApi(23) public static android.webkit.WebMessage! compatToFrameworkMessage(androidx.webkit.WebMessageCompat!);
    method @RequiresApi(23) public static android.webkit.WebMessagePort[]! compatToPorts(androidx.webkit.WebMessagePortCompat[]!);
    method @RequiresApi(23) public static androidx.webkit.WebMessageCompat! frameworkMessageToCompat(android.webkit.WebMessage!);
    method private org.chromium.support_lib_boundary.WebMessagePortBoundaryInterface! getBoundaryInterface();
    method @RequiresApi(23) public android.webkit.WebMessagePort! getFrameworkPort();
    method @RequiresApi(23) private android.webkit.WebMessagePort! getFrameworksImpl();
    method public java.lang.reflect.InvocationHandler! getInvocationHandler();
    method public static androidx.webkit.WebMessagePortCompat[]! portsToCompat(android.webkit.WebMessagePort[]!);
    field private org.chromium.support_lib_boundary.WebMessagePortBoundaryInterface! mBoundaryInterface;
    field private android.webkit.WebMessagePort! mFrameworksImpl;
  }

  public class WebResourceErrorImpl extends androidx.webkit.WebResourceErrorCompat {
    ctor public WebResourceErrorImpl(java.lang.reflect.InvocationHandler);
    ctor public WebResourceErrorImpl(android.webkit.WebResourceError);
    method private org.chromium.support_lib_boundary.WebResourceErrorBoundaryInterface! getBoundaryInterface();
    method @RequiresApi(23) private android.webkit.WebResourceError! getFrameworksImpl();
    field private org.chromium.support_lib_boundary.WebResourceErrorBoundaryInterface! mBoundaryInterface;
    field private android.webkit.WebResourceError! mFrameworksImpl;
  }

  public class WebResourceRequestAdapter {
    ctor public WebResourceRequestAdapter(org.chromium.support_lib_boundary.WebResourceRequestBoundaryInterface!);
    method public boolean isRedirect();
    field private final org.chromium.support_lib_boundary.WebResourceRequestBoundaryInterface! mBoundaryInterface;
  }

  public class WebSettingsAdapter {
    ctor public WebSettingsAdapter(org.chromium.support_lib_boundary.WebSettingsBoundaryInterface!);
    method public int getDisabledActionModeMenuItems();
    method public boolean getOffscreenPreRaster();
    method public boolean getSafeBrowsingEnabled();
    method public void setDisabledActionModeMenuItems(int);
    method public void setOffscreenPreRaster(boolean);
    method public void setSafeBrowsingEnabled(boolean);
    field private org.chromium.support_lib_boundary.WebSettingsBoundaryInterface! mBoundaryInterface;
  }

  public enum WebViewFeatureInternal {
    ctor private WebViewFeatureInternal(String!);
    ctor private WebViewFeatureInternal(String!, int);
    method public static androidx.webkit.internal.WebViewFeatureInternal! getFeature(String!);
    method public static UnsupportedOperationException! getUnsupportedOperationException();
    method public static String[]! getWebViewApkFeaturesForTesting();
    method public boolean isSupportedByFramework();
    method public boolean isSupportedByWebView();
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal CREATE_WEB_MESSAGE_CHANNEL;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal DISABLED_ACTION_MODE_MENU_ITEMS;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal GET_WEB_CHROME_CLIENT;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal GET_WEB_VIEW_CLIENT;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal GET_WEB_VIEW_RENDERER;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal OFF_SCREEN_PRERASTER;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal POST_WEB_MESSAGE;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal RECEIVE_HTTP_ERROR;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal RECEIVE_WEB_RESOURCE_ERROR;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SAFE_BROWSING_ENABLE;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SAFE_BROWSING_HIT;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SAFE_BROWSING_PRIVACY_POLICY_URL;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SAFE_BROWSING_RESPONSE_BACK_TO_SAFETY;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SAFE_BROWSING_RESPONSE_PROCEED;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SAFE_BROWSING_RESPONSE_SHOW_INTERSTITIAL;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SAFE_BROWSING_WHITELIST;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SERVICE_WORKER_BASIC_USAGE;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SERVICE_WORKER_BLOCK_NETWORK_LOADS;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SERVICE_WORKER_CACHE_MODE;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SERVICE_WORKER_CONTENT_ACCESS;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SERVICE_WORKER_FILE_ACCESS;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SERVICE_WORKER_SHOULD_INTERCEPT_REQUEST;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal SHOULD_OVERRIDE_WITH_REDIRECTS;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal START_SAFE_BROWSING;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal VISUAL_STATE_CALLBACK_FEATURE;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal WEB_MESSAGE_CALLBACK_ON_MESSAGE;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal WEB_MESSAGE_PORT_CLOSE;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal WEB_MESSAGE_PORT_POST_MESSAGE;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal WEB_MESSAGE_PORT_SET_MESSAGE_CALLBACK;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal WEB_RESOURCE_ERROR_GET_CODE;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal WEB_RESOURCE_ERROR_GET_DESCRIPTION;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal WEB_RESOURCE_REQUEST_IS_REDIRECT;
    enum_constant public static final androidx.webkit.internal.WebViewFeatureInternal WEB_VIEW_RENDERER_TERMINATE;
    field private static final int NOT_SUPPORTED_BY_FRAMEWORK = -1; // 0xffffffff
    field private final String! mFeatureValue;
    field private final int mOsVersion;
  }

  private static class WebViewFeatureInternal.LAZY_HOLDER {
    ctor private WebViewFeatureInternal.LAZY_HOLDER();
    field static final String[]! WEBVIEW_APK_FEATURES;
  }

  public class WebViewGlueCommunicator {
    ctor private WebViewGlueCommunicator();
    method static androidx.webkit.internal.WebViewProviderFactory! createGlueProviderFactory();
    method private static java.lang.reflect.InvocationHandler! fetchGlueProviderFactoryImpl() throws java.lang.ClassNotFoundException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException, java.lang.NoSuchMethodException;
    method public static androidx.webkit.internal.WebkitToCompatConverter! getCompatConverter();
    method public static androidx.webkit.internal.WebViewProviderFactory! getFactory();
    method public static ClassLoader! getWebViewClassLoader();
    method private static Object! getWebViewProviderFactory();
    field private static final String GLUE_FACTORY_PROVIDER_FETCHER_CLASS = "org.chromium.support_lib_glue.SupportLibReflectionUtil";
    field private static final String GLUE_FACTORY_PROVIDER_FETCHER_METHOD = "createWebViewProviderFactory";
  }

  private static class WebViewGlueCommunicator.LAZY_COMPAT_CONVERTER_HOLDER {
    ctor private WebViewGlueCommunicator.LAZY_COMPAT_CONVERTER_HOLDER();
    field static final androidx.webkit.internal.WebkitToCompatConverter! INSTANCE;
  }

  private static class WebViewGlueCommunicator.LAZY_FACTORY_HOLDER {
    ctor private WebViewGlueCommunicator.LAZY_FACTORY_HOLDER();
    field static final androidx.webkit.internal.WebViewProviderFactory! INSTANCE;
  }

  public class WebViewProviderAdapter {
    ctor public WebViewProviderAdapter(org.chromium.support_lib_boundary.WebViewProviderBoundaryInterface!);
    method public androidx.webkit.WebMessagePortCompat[]! createWebMessageChannel();
    method public android.webkit.WebChromeClient! getWebChromeClient();
    method public android.webkit.WebViewClient! getWebViewClient();
    method public androidx.webkit.WebViewRenderer! getWebViewRenderer() throws java.lang.Exception;
    method public void insertVisualStateCallback(long, androidx.webkit.WebViewCompat.VisualStateCallback!);
    method public void postWebMessage(androidx.webkit.WebMessageCompat!, android.net.Uri!);
    field org.chromium.support_lib_boundary.WebViewProviderBoundaryInterface! mImpl;
  }

  public interface WebViewProviderFactory {
    method public org.chromium.support_lib_boundary.WebViewProviderBoundaryInterface! createWebView(android.webkit.WebView!);
    method public org.chromium.support_lib_boundary.ServiceWorkerControllerBoundaryInterface! getServiceWorkerController();
    method public org.chromium.support_lib_boundary.StaticsBoundaryInterface! getStatics();
    method public String[]! getWebViewFeatures();
    method public org.chromium.support_lib_boundary.WebkitToCompatConverterBoundaryInterface! getWebkitToCompatConverter();
  }

  public class WebViewProviderFactoryAdapter implements androidx.webkit.internal.WebViewProviderFactory {
    ctor public WebViewProviderFactoryAdapter(org.chromium.support_lib_boundary.WebViewProviderFactoryBoundaryInterface!);
    method public org.chromium.support_lib_boundary.WebViewProviderBoundaryInterface! createWebView(android.webkit.WebView!);
    method public org.chromium.support_lib_boundary.ServiceWorkerControllerBoundaryInterface! getServiceWorkerController();
    method public org.chromium.support_lib_boundary.StaticsBoundaryInterface! getStatics();
    method public String[]! getWebViewFeatures();
    method public org.chromium.support_lib_boundary.WebkitToCompatConverterBoundaryInterface! getWebkitToCompatConverter();
    field org.chromium.support_lib_boundary.WebViewProviderFactoryBoundaryInterface! mImpl;
  }

  public class WebViewRendererImpl extends androidx.webkit.WebViewRenderer {
    ctor public WebViewRendererImpl(org.chromium.support_lib_boundary.WebViewRendererBoundaryInterface!);
    method public static androidx.webkit.internal.WebViewRendererImpl forInvocationHandler(java.lang.reflect.InvocationHandler!) throws java.lang.Exception;
    field private org.chromium.support_lib_boundary.WebViewRendererBoundaryInterface! mBoundaryInterface;
  }

  public class WebkitToCompatConverter {
    ctor public WebkitToCompatConverter(org.chromium.support_lib_boundary.WebkitToCompatConverterBoundaryInterface!);
    method java.lang.reflect.InvocationHandler! convertSafeBrowsingResponse(android.webkit.SafeBrowsingResponse!);
    method @RequiresApi(27) android.webkit.SafeBrowsingResponse! convertSafeBrowsingResponse(java.lang.reflect.InvocationHandler!);
    method public java.lang.reflect.InvocationHandler! convertServiceWorkerSettings(android.webkit.ServiceWorkerWebSettings!);
    method @RequiresApi(24) public android.webkit.ServiceWorkerWebSettings! convertServiceWorkerSettings(java.lang.reflect.InvocationHandler!);
    method public androidx.webkit.internal.WebSettingsAdapter! convertSettings(android.webkit.WebSettings!);
    method java.lang.reflect.InvocationHandler! convertWebMessagePort(android.webkit.WebMessagePort!);
    method @RequiresApi(23) android.webkit.WebMessagePort! convertWebMessagePort(java.lang.reflect.InvocationHandler!);
    method java.lang.reflect.InvocationHandler! convertWebResourceError(android.webkit.WebResourceError!);
    method @RequiresApi(23) android.webkit.WebResourceError! convertWebResourceError(java.lang.reflect.InvocationHandler!);
    method public androidx.webkit.internal.WebResourceRequestAdapter! convertWebResourceRequest(android.webkit.WebResourceRequest!);
    field private final org.chromium.support_lib_boundary.WebkitToCompatConverterBoundaryInterface! mImpl;
  }

}

package org.chromium.support_lib_boundary {

  public interface FeatureFlagHolderBoundaryInterface {
    method public String[]! getSupportedFeatures();
  }

  public interface IsomorphicObjectBoundaryInterface {
    method public Object! getOrCreatePeer(java.util.concurrent.Callable<java.lang.Object>!) throws java.lang.Exception;
  }

  public interface SafeBrowsingResponseBoundaryInterface {
    method public void backToSafety(boolean);
    method public void proceed(boolean);
    method public void showInterstitial(boolean);
  }

  public interface ServiceWorkerClientBoundaryInterface extends org.chromium.support_lib_boundary.FeatureFlagHolderBoundaryInterface {
    method public android.webkit.WebResourceResponse! shouldInterceptRequest(android.webkit.WebResourceRequest!);
  }

  public interface ServiceWorkerControllerBoundaryInterface {
    method public java.lang.reflect.InvocationHandler! getServiceWorkerWebSettings();
    method public void setServiceWorkerClient(java.lang.reflect.InvocationHandler!);
  }

  public interface ServiceWorkerWebSettingsBoundaryInterface {
    method public boolean getAllowContentAccess();
    method public boolean getAllowFileAccess();
    method public boolean getBlockNetworkLoads();
    method public int getCacheMode();
    method public void setAllowContentAccess(boolean);
    method public void setAllowFileAccess(boolean);
    method public void setBlockNetworkLoads(boolean);
    method public void setCacheMode(int);
  }

  public interface StaticsBoundaryInterface {
    method public void clearProxyOverride(Runnable!);
    method public android.net.Uri! getSafeBrowsingPrivacyPolicyUrl();
    method public void initSafeBrowsing(android.content.Context!, android.webkit.ValueCallback<java.lang.Boolean>!);
    method public void setProxyOverride(String!, int, String[]!, Runnable!);
    method public void setSafeBrowsingWhitelist(java.util.List<java.lang.String>!, android.webkit.ValueCallback<java.lang.Boolean>!);
  }

  public interface TracingControllerBoundaryInterface {
    method public boolean isTracing();
    method public void start(int, java.util.Collection<java.lang.String>!, int) throws java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public boolean stop(java.io.OutputStream!, java.util.concurrent.Executor!);
  }

  public interface VisualStateCallbackBoundaryInterface {
    method public void onComplete(long);
  }

  public interface WebMessageBoundaryInterface extends org.chromium.support_lib_boundary.FeatureFlagHolderBoundaryInterface {
    method public String! getData();
    method public java.lang.reflect.InvocationHandler[]! getPorts();
  }

  public interface WebMessageCallbackBoundaryInterface extends org.chromium.support_lib_boundary.FeatureFlagHolderBoundaryInterface {
    method public void onMessage(java.lang.reflect.InvocationHandler!, java.lang.reflect.InvocationHandler!);
  }

  public interface WebMessagePortBoundaryInterface {
    method public void close();
    method public void postMessage(java.lang.reflect.InvocationHandler!);
    method public void setWebMessageCallback(java.lang.reflect.InvocationHandler!);
    method public void setWebMessageCallback(java.lang.reflect.InvocationHandler!, android.os.Handler!);
  }

  public interface WebResourceErrorBoundaryInterface {
    method public CharSequence! getDescription();
    method public int getErrorCode();
  }

  public interface WebResourceRequestBoundaryInterface {
    method public boolean isRedirect();
  }

  public interface WebSettingsBoundaryInterface {
    method public int getDisabledActionModeMenuItems();
    method public boolean getOffscreenPreRaster();
    method public boolean getSafeBrowsingEnabled();
    method public void setDisabledActionModeMenuItems(int);
    method public void setOffscreenPreRaster(boolean);
    method public void setSafeBrowsingEnabled(boolean);
  }

  public interface WebViewClientBoundaryInterface extends org.chromium.support_lib_boundary.FeatureFlagHolderBoundaryInterface {
    method public void onPageCommitVisible(android.webkit.WebView!, String!);
    method public void onReceivedError(android.webkit.WebView!, android.webkit.WebResourceRequest!, java.lang.reflect.InvocationHandler!);
    method public void onReceivedHttpError(android.webkit.WebView!, android.webkit.WebResourceRequest!, android.webkit.WebResourceResponse!);
    method public void onSafeBrowsingHit(android.webkit.WebView!, android.webkit.WebResourceRequest!, int, java.lang.reflect.InvocationHandler!);
    method public boolean shouldOverrideUrlLoading(android.webkit.WebView!, android.webkit.WebResourceRequest!);
  }

  public interface WebViewProviderBoundaryInterface {
    method public java.lang.reflect.InvocationHandler[]! createWebMessageChannel();
    method public android.webkit.WebChromeClient! getWebChromeClient();
    method public android.webkit.WebViewClient! getWebViewClient();
    method public java.lang.reflect.InvocationHandler! getWebViewRenderer();
    method public void insertVisualStateCallback(long, java.lang.reflect.InvocationHandler!);
    method public void postMessageToMainFrame(java.lang.reflect.InvocationHandler!, android.net.Uri!);
  }

  public interface WebViewProviderFactoryBoundaryInterface {
    method public java.lang.reflect.InvocationHandler! createWebView(android.webkit.WebView!);
    method public java.lang.reflect.InvocationHandler! getServiceWorkerController();
    method public java.lang.reflect.InvocationHandler! getStatics();
    method public String[]! getSupportedFeatures();
    method public java.lang.reflect.InvocationHandler! getTracingController();
    method public java.lang.reflect.InvocationHandler! getWebkitToCompatConverter();
  }

  public interface WebViewRendererBoundaryInterface extends org.chromium.support_lib_boundary.IsomorphicObjectBoundaryInterface {
    method public boolean terminate();
  }

  public interface WebkitToCompatConverterBoundaryInterface {
    method public java.lang.reflect.InvocationHandler! convertSafeBrowsingResponse(Object!);
    method public Object! convertSafeBrowsingResponse(java.lang.reflect.InvocationHandler!);
    method public java.lang.reflect.InvocationHandler! convertServiceWorkerSettings(Object!);
    method public Object! convertServiceWorkerSettings(java.lang.reflect.InvocationHandler!);
    method public java.lang.reflect.InvocationHandler! convertSettings(android.webkit.WebSettings!);
    method public java.lang.reflect.InvocationHandler! convertWebMessagePort(Object!);
    method public Object! convertWebMessagePort(java.lang.reflect.InvocationHandler!);
    method public java.lang.reflect.InvocationHandler! convertWebResourceError(Object!);
    method public Object! convertWebResourceError(java.lang.reflect.InvocationHandler!);
    method public java.lang.reflect.InvocationHandler! convertWebResourceRequest(android.webkit.WebResourceRequest!);
  }

}

package org.chromium.support_lib_boundary.util {

  public class BoundaryInterfaceReflectionUtil {
    ctor public BoundaryInterfaceReflectionUtil();
    method public static <T> T! castToSuppLibClass(Class<T>!, java.lang.reflect.InvocationHandler!);
    method public static boolean containsFeature(String[]!, String!);
    method public static java.lang.reflect.InvocationHandler! createInvocationHandlerFor(Object!);
    method public static java.lang.reflect.Method! dupeMethod(java.lang.reflect.Method!, ClassLoader!) throws java.lang.ClassNotFoundException, java.lang.NoSuchMethodException;
    method public static Object! getDelegateFromInvocationHandler(java.lang.reflect.InvocationHandler!);
    method public static boolean instanceOfInOwnClassLoader(Object!, String!);
  }

  private static class BoundaryInterfaceReflectionUtil.InvocationHandlerWithDelegateGetter implements java.lang.reflect.InvocationHandler {
    ctor public BoundaryInterfaceReflectionUtil.InvocationHandlerWithDelegateGetter(Object!);
    method public Object! getDelegate();
    field private final Object! mDelegate;
  }

  public class Features {
    ctor private Features();
    field public static final String CREATE_WEB_MESSAGE_CHANNEL = "CREATE_WEB_MESSAGE_CHANNEL";
    field public static final String DISABLED_ACTION_MODE_MENU_ITEMS = "DISABLED_ACTION_MODE_MENU_ITEMS";
    field public static final String GET_WEB_CHROME_CLIENT = "GET_WEB_CHROME_CLIENT";
    field public static final String GET_WEB_VIEW_CLIENT = "GET_WEB_VIEW_CLIENT";
    field public static final String GET_WEB_VIEW_RENDERER = "GET_WEB_VIEW_RENDERER";
    field public static final String OFF_SCREEN_PRERASTER = "OFF_SCREEN_PRERASTER";
    field public static final String POST_WEB_MESSAGE = "POST_WEB_MESSAGE";
    field public static final String PROXY_OVERRIDE = "PROXY_OVERRIDE:2";
    field public static final String RECEIVE_HTTP_ERROR = "RECEIVE_HTTP_ERROR";
    field public static final String RECEIVE_WEB_RESOURCE_ERROR = "RECEIVE_WEB_RESOURCE_ERROR";
    field public static final String SAFE_BROWSING_ENABLE = "SAFE_BROWSING_ENABLE";
    field public static final String SAFE_BROWSING_HIT = "SAFE_BROWSING_HIT";
    field public static final String SAFE_BROWSING_PRIVACY_POLICY_URL = "SAFE_BROWSING_PRIVACY_POLICY_URL";
    field public static final String SAFE_BROWSING_RESPONSE_BACK_TO_SAFETY = "SAFE_BROWSING_RESPONSE_BACK_TO_SAFETY";
    field public static final String SAFE_BROWSING_RESPONSE_PROCEED = "SAFE_BROWSING_RESPONSE_PROCEED";
    field public static final String SAFE_BROWSING_RESPONSE_SHOW_INTERSTITIAL = "SAFE_BROWSING_RESPONSE_SHOW_INTERSTITIAL";
    field public static final String SAFE_BROWSING_WHITELIST = "SAFE_BROWSING_WHITELIST";
    field public static final String SERVICE_WORKER_BASIC_USAGE = "SERVICE_WORKER_BASIC_USAGE";
    field public static final String SERVICE_WORKER_BLOCK_NETWORK_LOADS = "SERVICE_WORKER_BLOCK_NETWORK_LOADS";
    field public static final String SERVICE_WORKER_CACHE_MODE = "SERVICE_WORKER_CACHE_MODE";
    field public static final String SERVICE_WORKER_CONTENT_ACCESS = "SERVICE_WORKER_CONTENT_ACCESS";
    field public static final String SERVICE_WORKER_FILE_ACCESS = "SERVICE_WORKER_FILE_ACCESS";
    field public static final String SERVICE_WORKER_SHOULD_INTERCEPT_REQUEST = "SERVICE_WORKER_SHOULD_INTERCEPT_REQUEST";
    field public static final String SHOULD_OVERRIDE_WITH_REDIRECTS = "SHOULD_OVERRIDE_WITH_REDIRECTS";
    field public static final String START_SAFE_BROWSING = "START_SAFE_BROWSING";
    field public static final String TRACING_CONTROLLER_BASIC_USAGE = "TRACING_CONTROLLER_BASIC_USAGE";
    field public static final String VISUAL_STATE_CALLBACK = "VISUAL_STATE_CALLBACK";
    field public static final String WEB_MESSAGE_CALLBACK_ON_MESSAGE = "WEB_MESSAGE_CALLBACK_ON_MESSAGE";
    field public static final String WEB_MESSAGE_PORT_CLOSE = "WEB_MESSAGE_PORT_CLOSE";
    field public static final String WEB_MESSAGE_PORT_POST_MESSAGE = "WEB_MESSAGE_PORT_POST_MESSAGE";
    field public static final String WEB_MESSAGE_PORT_SET_MESSAGE_CALLBACK = "WEB_MESSAGE_PORT_SET_MESSAGE_CALLBACK";
    field public static final String WEB_RESOURCE_ERROR_GET_CODE = "WEB_RESOURCE_ERROR_GET_CODE";
    field public static final String WEB_RESOURCE_ERROR_GET_DESCRIPTION = "WEB_RESOURCE_ERROR_GET_DESCRIPTION";
    field public static final String WEB_RESOURCE_REQUEST_IS_REDIRECT = "WEB_RESOURCE_REQUEST_IS_REDIRECT";
    field public static final String WEB_VIEW_RENDERER_TERMINATE = "WEB_VIEW_RENDERER_TERMINATE";
  }

}

